import CoreData
import Foundation

enum TimeoutError: Error {
    case timeout
}

enum APIError: Error {
    case apiKeyNotConfigured
    case networkError
}

struct EnhancedVideoDetails {
    let description: String
    let duration: Int
    let viewCount: Int
    let publishedAt: String
}

struct VideoTranscript {
    let text: String
    let language: String
    let autoGenerated: Bool
}

struct EnhancedYouTubeVideo {
    let videoId: String
    let title: String
    let channel: String
    let description: String
    let duration: Int
    let transcript: VideoTranscript?
    let difficultyAnalysis: DifficultyAnalysis
}

struct DifficultyAnalysis {
    let difficulty: Int
    let confidence: Double
    let targetAudience: String
    let keySkills: [String]
    let reasoning: [String]
}

class CoreDataManager: ObservableObject {
    static let shared = CoreDataManager()

    // Circuit breaker state for API protection
    private var consecutiveFailures = 0
    private let maxConsecutiveFailures = 3

    // Simple in-memory cache for video details
    private var videoDetailsCache: [String: EnhancedVideoDetails] = [:]
    private var transcriptCache: [String: VideoTranscript] = [:]
    private let cacheExpirationTime: TimeInterval = 30 * 60  // 30 minutes

    /// Published error state so UI can react to Core Data failures
    @Published var persistentStoreError: Error?

    lazy var persistentContainer: NSPersistentContainer = {
        let container = NSPersistentContainer(name: "DataModel")

        // Enable lightweight migration
        let description = container.persistentStoreDescriptions.first
        description?.shouldMigrateStoreAutomatically = true
        description?.shouldInferMappingModelAutomatically = true

        container.loadPersistentStores { storeDescription, error in
            if let error = error as NSError? {
                // If there's a migration error, delete the store and recreate
                #if DEBUG
                print("‚ö†Ô∏è Core Data error: \(error.localizedDescription)")
                #endif
                #if DEBUG
                print("üîÑ Attempting to reset Core Data store...")

                #endif
                if let storeURL = storeDescription.url {
                    do {
                        try FileManager.default.removeItem(at: storeURL)
                        #if DEBUG
                        print("‚úÖ Deleted corrupted store, will recreate")

                        #endif
                        // Try loading again
                        container.loadPersistentStores { [weak self] _, retryError in
                            if let retryError = retryError {
                                #if DEBUG
                                print("‚ùå Failed to recreate Core Data store: \(retryError.localizedDescription)")
                                #endif
                                self?.persistentStoreError = retryError
                            } else {
                                #if DEBUG
                                print("Successfully recreated Core Data store")
                                #endif
                            }
                        }
                    } catch {
                        #if DEBUG
                        print("‚ùå Failed to delete corrupted Core Data store: \(error.localizedDescription)")
                        #endif
                        self.persistentStoreError = error
                    }
                }
            }
        }

        container.viewContext.automaticallyMergesChangesFromParent = true
        return container
    }()
    
    var context: NSManagedObjectContext {
        return persistentContainer.viewContext
    }
    
    func save() {
        if context.hasChanges {
            do {
                try context.save()
            } catch {
                #if DEBUG
                print("Save error: \(error.localizedDescription)")
                #endif
            }
        }
    }
}

extension CoreDataManager {
    // MARK: - User-aware data fetching

    /// Convenience method to get current player using AuthenticationManager
    func getCurrentPlayer() -> Player? {
        let userUID = AuthenticationManager.shared.userUID
        guard !userUID.isEmpty else { return nil }
        return getCurrentPlayer(for: userUID)
    }

    func getCurrentPlayer(for firebaseUID: String) -> Player? {
        let request: NSFetchRequest<Player> = Player.fetchRequest()
        request.predicate = NSPredicate(format: "firebaseUID == %@", firebaseUID)
        request.fetchLimit = 1
        
        do {
            return try context.fetch(request).first
        } catch {
            #if DEBUG
            print("‚ùå Failed to fetch current player: \(error)")
            #endif
            return nil
        }
    }
    
    func fetchTrainingSessions(for firebaseUID: String) -> [TrainingSession] {
        guard let player = getCurrentPlayer(for: firebaseUID) else {
            #if DEBUG
            print("‚ö†Ô∏è No player found for Firebase UID: \(firebaseUID)")
            #endif
            return []
        }
        
        let request: NSFetchRequest<TrainingSession> = TrainingSession.fetchRequest()
        request.predicate = NSPredicate(format: "player == %@", player)
        request.sortDescriptors = [NSSortDescriptor(keyPath: \TrainingSession.date, ascending: false)]
        
        do {
            let sessions = try context.fetch(request)
            #if DEBUG
            print("üìä Found \(sessions.count) training sessions for user \(firebaseUID)")
            #endif
            return sessions
        } catch {
            #if DEBUG
            print("‚ùå Failed to fetch training sessions: \(error)")
            #endif
            return []
        }
    }
    
    func fetchExercises(for firebaseUID: String) -> [Exercise] {
        guard let player = getCurrentPlayer(for: firebaseUID) else {
            #if DEBUG
            print("‚ö†Ô∏è No player found for Firebase UID: \(firebaseUID)")
            #endif
            return []
        }
        
        return fetchExercises(for: player)
    }
    
    func createDefaultExercises(for player: Player) {
        // Check if exercises already exist for this player to prevent duplicates
        let existingExercises = fetchExercises(for: player)
        if !existingExercises.isEmpty {
            #if DEBUG
            print("üìö Exercises already exist for player \(player.name ?? "Unknown"), skipping default creation")
            #endif
            return
        }
        
        let exercises = [
            ("Ball Control", "Technical", 1, "Basic ball touches and control", ["Ball Control", "First Touch"]),
            ("Juggling", "Technical", 2, "Keep the ball in the air using different body parts", ["Ball Control", "Coordination"]),
            ("Dribbling Cones", "Technical", 2, "Dribble through a series of cones", ["Dribbling", "Agility"]),
            ("Shooting Practice", "Technical", 3, "Practice shooting accuracy and power", ["Shooting", "Accuracy"]),
            ("Passing Accuracy", "Technical", 2, "Short and long passing practice", ["Passing", "Vision"]),
            ("Sprint Training", "Physical", 2, "Short distance sprint intervals", ["Speed", "Acceleration"]),
            ("Agility Ladder", "Physical", 2, "Footwork and agility drills", ["Agility", "Coordination"]),
            ("Endurance Run", "Physical", 1, "Continuous running for stamina", ["Endurance", "Fitness"]),
            ("1v1 Practice", "Tactical", 3, "One-on-one attacking and defending", ["Defending", "Attacking"]),
            ("Small-Sided Games", "Tactical", 3, "3v3 or 4v4 mini games", ["Teamwork", "Decision Making"])
        ]
        
        for (name, category, difficulty, description, skills) in exercises {
            // Check if exercise with this name already exists for this player
            if !exerciseExists(name: name, for: player) {
                let exercise = Exercise(context: context)
                exercise.id = UUID()
                exercise.name = name
                exercise.category = category
                exercise.difficulty = Int16(difficulty)
                exercise.exerciseDescription = description
                exercise.targetSkills = skills
                exercise.instructions = "Follow standard \(name.lowercased()) protocol"
                exercise.setValue(player, forKey: "player")
            }
        }
        
        save()
    }
    
    private func exerciseExists(name: String, for player: Player) -> Bool {
        let request: NSFetchRequest<Exercise> = Exercise.fetchRequest()
        request.predicate = NSPredicate(format: "name == %@ AND player == %@", name, player)
        
        do {
            let count = try context.count(for: request)
            return count > 0
        } catch {
            #if DEBUG
            print("‚ùå Failed to check exercise existence: \(error)")
            #endif
            return false
        }
    }
    
    func fetchExercises(for player: Player) -> [Exercise] {
        let request: NSFetchRequest<Exercise> = Exercise.fetchRequest()
        request.predicate = NSPredicate(format: "player == %@", player)
        request.sortDescriptors = [NSSortDescriptor(keyPath: \Exercise.name, ascending: true)]

        do {
            return try context.fetch(request)
        } catch {
            #if DEBUG
            print("‚ùå Failed to fetch exercises for player: \(error)")
            #endif
            return []
        }
    }

    // MARK: - Exercise Favorites & Recent

    /// Toggle favorite status for an exercise
    func toggleFavorite(exercise: Exercise) {
        exercise.isFavorite.toggle()
        save()
        #if DEBUG
        print("‚≠ê Exercise '\(exercise.name ?? "Unknown")' favorite status: \(exercise.isFavorite)")
        #endif
    }

    /// Fetch all favorite exercises for a player
    func fetchFavoriteExercises(for player: Player) -> [Exercise] {
        let request: NSFetchRequest<Exercise> = Exercise.fetchRequest()
        request.predicate = NSPredicate(format: "player == %@ AND isFavorite == YES", player)
        request.sortDescriptors = [NSSortDescriptor(keyPath: \Exercise.name, ascending: true)]

        do {
            return try context.fetch(request)
        } catch {
            #if DEBUG
            print("‚ùå Failed to fetch favorite exercises: \(error)")
            #endif
            return []
        }
    }

    /// Fetch recently used exercises for a player
    func fetchRecentlyUsedExercises(for player: Player, limit: Int = 5) -> [Exercise] {
        let request: NSFetchRequest<Exercise> = Exercise.fetchRequest()
        request.predicate = NSPredicate(format: "player == %@ AND lastUsedAt != nil", player)
        request.sortDescriptors = [NSSortDescriptor(keyPath: \Exercise.lastUsedAt, ascending: false)]
        request.fetchLimit = limit

        do {
            return try context.fetch(request)
        } catch {
            #if DEBUG
            print("‚ùå Failed to fetch recently used exercises: \(error)")
            #endif
            return []
        }
    }

    /// Record that an exercise was used (updates lastUsedAt timestamp)
    func recordExerciseUsage(exercise: Exercise) {
        exercise.lastUsedAt = Date()
        save()
    }

    /// Update exercise with new values
    func updateExercise(
        exercise: Exercise,
        name: String? = nil,
        description: String? = nil,
        category: String? = nil,
        difficulty: Int16? = nil,
        instructions: String? = nil,
        targetSkills: [String]? = nil,
        personalNotes: String? = nil
    ) {
        if let name = name { exercise.name = name }
        if let description = description { exercise.exerciseDescription = description }
        if let category = category { exercise.category = category }
        if let difficulty = difficulty { exercise.difficulty = difficulty }
        if let instructions = instructions { exercise.instructions = instructions }
        if let targetSkills = targetSkills { exercise.targetSkills = targetSkills }
        if let personalNotes = personalNotes { exercise.personalNotes = personalNotes }

        save()
        #if DEBUG
        print("‚úèÔ∏è Updated exercise: \(exercise.name ?? "Unknown")")
        #endif
    }

    /// Delete an exercise
    func deleteExercise(_ exercise: Exercise) {
        let exerciseName = exercise.name ?? "Unknown"
        context.delete(exercise)
        save()
        #if DEBUG
        print("üóëÔ∏è Deleted exercise: \(exerciseName)")
        #endif
    }

    // MARK: - YouTube Integration
    
    func createExerciseFromYouTubeVideo(
        for player: Player,
        videoId: String,
        title: String,
        description: String,
        thumbnailURL: String,
        duration: Int,
        channelTitle: String,
        category: String = "Technical",
        difficulty: Int = 2,
        targetSkills: [String] = []
    ) -> Exercise? {
        // Check if exercise with this title already exists for this player
        if exerciseExists(name: title, for: player) {
            #if DEBUG
            print("üìö Exercise '\(title)' already exists for player \(player.name ?? "Unknown"), skipping creation")
            #endif
            return fetchExerciseByName(title, for: player)
        }
        
        // Check if exercise with this YouTube video ID already exists for this player
        if youTubeExerciseExists(videoId: videoId, for: player) {
            #if DEBUG
            print("üì∫ YouTube exercise with video ID '\(videoId)' already exists for player \(player.name ?? "Unknown"), skipping creation")
            #endif
            return fetchExerciseByVideoId(videoId, for: player)
        }
        
        let exercise = Exercise(context: context)
        exercise.id = UUID()
        exercise.name = title
        exercise.category = category
        exercise.difficulty = Int16(difficulty)
        exercise.exerciseDescription = description
        exercise.instructions = "Watch this YouTube video to learn the technique, then practice in real life."
        exercise.targetSkills = targetSkills
        exercise.setValue(player, forKey: "player")
        
        // Store YouTube info in the description for now (until Core Data fields are available)
        exercise.exerciseDescription = "\(description)\n\nüé• YouTube Video\nChannel: \(channelTitle)\nVideo ID: \(videoId)"
        exercise.instructions = "1. Watch the YouTube video at: https://youtube.com/watch?v=\(videoId)\n2. Practice the technique shown\n3. Focus on the key points demonstrated"
        
        save()
        return exercise
    }
    
    private func youTubeExerciseExists(videoId: String, for player: Player) -> Bool {
        let request: NSFetchRequest<Exercise> = Exercise.fetchRequest()
        request.predicate = NSPredicate(format: "exerciseDescription CONTAINS %@ AND player == %@", "Video ID: \(videoId)", player)
        
        do {
            let count = try context.count(for: request)
            return count > 0
        } catch {
            #if DEBUG
            print("‚ùå Failed to check YouTube exercise existence: \(error)")
            #endif
            return false
        }
    }
    
    private func fetchExerciseByName(_ name: String, for player: Player) -> Exercise? {
        let request: NSFetchRequest<Exercise> = Exercise.fetchRequest()
        request.predicate = NSPredicate(format: "name == %@ AND player == %@", name, player)
        request.fetchLimit = 1
        
        do {
            return try context.fetch(request).first
        } catch {
            #if DEBUG
            print("‚ùå Failed to fetch exercise by name: \(error)")
            #endif
            return nil
        }
    }
    
    private func fetchExerciseByVideoId(_ videoId: String, for player: Player) -> Exercise? {
        let request: NSFetchRequest<Exercise> = Exercise.fetchRequest()
        request.predicate = NSPredicate(format: "exerciseDescription CONTAINS %@ AND player == %@", "Video ID: \(videoId)", player)
        request.fetchLimit = 1
        
        do {
            return try context.fetch(request).first
        } catch {
            #if DEBUG
            print("‚ùå Failed to fetch exercise by video ID: \(error)")
            #endif
            return nil
        }
    }
    
    func loadYouTubeDrillsFromAPI(
        for player: Player, 
        category: String? = nil, 
        maxResults: Int = 10, 
        progressCallback: (@Sendable @MainActor (Double, String) -> Void)? = nil
    ) async throws {
        #if DEBUG
        print("üöÄ Starting YouTube drill analysis with enhanced difficulty detection")
        #endif
        #if DEBUG
        print("üìã Category: \(category ?? "All"), Max Results: \(maxResults)")
        
        #endif
        // Use the same method as YouTubeConfig for consistency
        guard let path = Bundle.main.path(forResource: "Info", ofType: "plist"),
              let plist = NSDictionary(contentsOfFile: path),
              let apiKey = plist["YOUTUBE_API_KEY"] as? String,
              !apiKey.isEmpty,
              apiKey != "YOUR_YOUTUBE_API_KEY_HERE" else {
            #if DEBUG
            print("‚ö†Ô∏è YouTube API key not found or not configured in Info.plist")
            #endif
            await progressCallback?(0.0, "API key not configured")
            throw APIError.apiKeyNotConfigured
        }
        
        Task { [self] in
            do {
                await progressCallback?(0.1, "Searching YouTube...")
                
                let searchQuery = category ?? "soccer training drills"
                #if DEBUG
                print("üîç Performing enhanced YouTube search for: \(searchQuery)")
                #endif
                #if DEBUG
                print("üìù Note: Transcript analysis will be attempted but may not be available for all videos due to privacy restrictions")
                
                #endif
                // Use enhanced search with transcript analysis, fallback to basic search if needed
                let enhancedVideos: [EnhancedYouTubeVideo]
                
                do {
                    await progressCallback?(0.2, "Analyzing videos...")
                    enhancedVideos = try await performEnhancedYouTubeSearch(
                        query: searchQuery, 
                        apiKey: apiKey, 
                        maxResults: maxResults
                    )
                } catch {
                    #if DEBUG
                    print("‚ö†Ô∏è Enhanced search failed, falling back to basic search: \(error)")
                    #endif
                    await progressCallback?(0.3, "Using basic search...")
                    
                    // Fallback to basic search without enhanced analysis
                    let basicVideos = try await self.performYouTubeSearch(query: searchQuery, apiKey: apiKey, maxResults: maxResults)
                    enhancedVideos = basicVideos.map { video in
                        let basicAnalysis = analyzeVideoDifficultyComprehensive(
                            title: video.title,
                            description: "",
                            transcript: nil,
                            duration: 300, // Default duration
                            channelTitle: video.channel
                        )
                        return EnhancedYouTubeVideo(
                            videoId: video.videoId,
                            title: video.title,
                            channel: video.channel,
                            description: video.title, // Use title as description fallback
                            duration: 300,
                            transcript: nil,
                            difficultyAnalysis: basicAnalysis
                        )
                    }
                }
                
                await progressCallback?(0.6, "Creating exercises...")
                
                let totalVideos = enhancedVideos.count
                for (index, video) in enhancedVideos.enumerated() {
                    // Update progress for each video
                    let videoProgress = 0.6 + (0.3 * Double(index) / Double(totalVideos))
                    await progressCallback?(videoProgress, "Processing video \(index + 1) of \(totalVideos)")
                    
                    // Check if we already have this video
                    let existingExercise = findExerciseByYouTubeID(video.videoId, for: player)
                    if existingExercise == nil {
                        
                        #if DEBUG
                        
                        print("üìä Video Analysis for '\(video.title.prefix(50))...':")
                        
                        #endif
                        #if DEBUG
                        print("   Difficulty: \(video.difficultyAnalysis.difficulty)/5")
                        #endif
                        #if DEBUG
                        print("   Confidence: \(String(format: "%.1f", video.difficultyAnalysis.confidence * 100))%")
                        #endif
                        #if DEBUG
                        print("   Target: \(video.difficultyAnalysis.targetAudience)")
                        #endif
                        #if DEBUG
                        print("   Skills: \(video.difficultyAnalysis.keySkills.joined(separator: ", "))")
                        #endif
                        #if DEBUG
                        print("   Transcript: \(video.transcript != nil ? "‚úÖ Available" : "‚ùå Not available")")
                        #endif
                        if !video.difficultyAnalysis.reasoning.isEmpty {
                            #if DEBUG
                            print("   Reasoning: \(video.difficultyAnalysis.reasoning.prefix(3).joined(separator: "; "))")
                            #endif
                        }
                        
                        _ = createEnhancedExerciseFromYouTubeVideo(
                            for: player,
                            videoId: video.videoId,
                            title: video.title,
                            description: video.description,
                            thumbnailURL: "https://img.youtube.com/vi/\(video.videoId)/medium.jpg",
                            duration: video.duration,
                            channelTitle: video.channel,
                            category: category ?? "Technical",
                            difficultyAnalysis: video.difficultyAnalysis,
                            transcript: video.transcript
                        )
                    }
                }
                await progressCallback?(0.95, "Finalizing...")
            } catch {
                #if DEBUG
                print("Error loading YouTube drills: \(error)")
                #endif
                await progressCallback?(0.0, "Error occurred")
            }
        }
    }
    
    // Enhanced exercise creation with comprehensive analysis
    private func createEnhancedExerciseFromYouTubeVideo(
        for player: Player,
        videoId: String,
        title: String,
        description: String,
        thumbnailURL: String,
        duration: Int,
        channelTitle: String,
        category: String,
        difficultyAnalysis: DifficultyAnalysis,
        transcript: VideoTranscript?
    ) -> Exercise {
        let exercise = Exercise(context: context)
        exercise.id = UUID()
        exercise.name = title
        exercise.category = category
        exercise.difficulty = Int16(difficultyAnalysis.difficulty)
        exercise.exerciseDescription = description
        exercise.targetSkills = difficultyAnalysis.keySkills
        exercise.setValue(player, forKey: "player")
        // Set YouTube-specific fields if available
        exercise.setValue(true, forKey: "isYouTubeContent")
        exercise.setValue(videoId, forKey: "youtubeVideoID")
        exercise.setValue(thumbnailURL, forKey: "videoThumbnailURL")
        exercise.setValue(Int32(duration), forKey: "videoDuration")
        
        // Enhanced description with analysis insights
        var enhancedDescription = description
        if !enhancedDescription.isEmpty {
            enhancedDescription += "\n\n"
        }
        
        enhancedDescription += "üéØ Difficulty Analysis:\n"
        enhancedDescription += "‚Ä¢ Level: \(difficultyAnalysis.difficulty)/5 (\(difficultyAnalysis.targetAudience))\n"
        enhancedDescription += "‚Ä¢ Confidence: \(Int(difficultyAnalysis.confidence * 100))%\n"
        
        if !difficultyAnalysis.keySkills.isEmpty {
            enhancedDescription += "‚Ä¢ Skills: \(difficultyAnalysis.keySkills.joined(separator: ", "))\n"
        }
        
        if transcript != nil {
            enhancedDescription += "‚Ä¢ Full transcript available for detailed analysis\n"
        }
        
        if !difficultyAnalysis.reasoning.isEmpty {
            enhancedDescription += "‚Ä¢ Analysis: \(difficultyAnalysis.reasoning.joined(separator: "; "))\n"
        }
        
        enhancedDescription += "\nüé• YouTube Video\nChannel: \(channelTitle)\nDuration: \(formatDuration(duration))"
        
        exercise.exerciseDescription = enhancedDescription
        
        // Enhanced instructions based on difficulty level
        var instructions = "1. Watch the YouTube video at: https://youtube.com/watch?v=\(videoId)\n"
        
        switch difficultyAnalysis.difficulty {
        case 1:
            instructions += "2. This is a beginner drill - focus on proper form over speed\n"
            instructions += "3. Practice slowly and build confidence\n"
            instructions += "4. Master the basics before progressing"
        case 2:
            instructions += "2. This is an intermediate drill - ensure you have the fundamentals\n"
            instructions += "3. Focus on technique and consistency\n"
            instructions += "4. Gradually increase intensity as you improve"
        case 3:
            instructions += "2. This is an advanced drill - requires solid fundamentals\n"
            instructions += "3. Pay attention to timing and coordination\n"
            instructions += "4. Challenge yourself while maintaining quality"
        case 4:
            instructions += "2. This is an expert-level drill - master prerequisite skills first\n"
            instructions += "3. Focus on precision and game-like intensity\n"
            instructions += "4. Analyze your performance critically"
        default:
            instructions += "2. This is a professional-level drill - elite technique required\n"
            instructions += "3. Perfect execution under pressure is essential\n"
            instructions += "4. Seek coaching feedback for refinement"
        }
        
        exercise.instructions = instructions
        
        save()
        return exercise
    }
    
    private func formatDuration(_ seconds: Int) -> String {
        let minutes = seconds / 60
        let remainingSeconds = seconds % 60
        return String(format: "%d:%02d", minutes, remainingSeconds)
    }
    
    private func findExerciseByYouTubeID(_ videoId: String, for player: Player) -> Exercise? {
        let request: NSFetchRequest<Exercise> = Exercise.fetchRequest()
        // Check both the new youtubeVideoID field and legacy description format
        // Use value(forKey:) to safely check YouTube fields
        request.predicate = NSPredicate(format: "exerciseDescription CONTAINS %@ AND player == %@", "Video ID: \(videoId)", player)
        request.fetchLimit = 1
        
        do {
            let results = try context.fetch(request)
            return results.first
        } catch {
            #if DEBUG
            print("Error finding exercise by YouTube ID: \(error)")
            #endif
            return nil
        }
    }
    
    private func analyzeVideoForSkills(title: String, description: String) -> [String] {
        let content = (title + " " + description).lowercased()
        var skills: [String] = []
        
        if content.contains("dribbling") || content.contains("dribble") {
            skills.append("Dribbling")
        }
        if content.contains("passing") || content.contains("pass") {
            skills.append("Passing")
        }
        if content.contains("shooting") || content.contains("shot") {
            skills.append("Shooting")
        }
        if content.contains("control") || content.contains("touch") {
            skills.append("Ball Control")
        }
        if content.contains("speed") || content.contains("sprint") {
            skills.append("Speed")
        }
        if content.contains("agility") || content.contains("footwork") {
            skills.append("Agility")
        }
        
        return skills.isEmpty ? ["Ball Control"] : skills
    }
    
    private func analyzeVideoDifficulty(title: String) -> Int {
        let analysis = analyzeVideoDifficultyComprehensive(
            title: title,
            description: "",
            transcript: nil,
            duration: 0,
            channelTitle: ""
        )
        return analysis.difficulty
    }
    
    // MARK: - Enhanced Difficulty Analysis System
    
    // Using DifficultyAnalysis and VideoTranscript from YouTubeModels.swift
    
    private func analyzeVideoDifficultyComprehensive(
        title: String,
        description: String,
        transcript: String?,
        duration: Int,
        channelTitle: String
    ) -> DifficultyAnalysis {
        
        var totalScore: Double = 0
        var confidenceScore: Double = 0
        var reasoning: [String] = []
        var keySkills: [String] = []
        
        // Title Analysis (20% weight)
        let titleAnalysis = analyzeTitleDifficulty(title)
        totalScore += titleAnalysis.score * 0.2
        confidenceScore += titleAnalysis.confidence * 0.2
        reasoning.append(contentsOf: titleAnalysis.reasoning)
        keySkills.append(contentsOf: titleAnalysis.skills)
        
        // Description Analysis (30% weight)
        let descriptionAnalysis = analyzeDescriptionDifficulty(description)
        totalScore += descriptionAnalysis.score * 0.3
        confidenceScore += descriptionAnalysis.confidence * 0.3
        reasoning.append(contentsOf: descriptionAnalysis.reasoning)
        keySkills.append(contentsOf: descriptionAnalysis.skills)
        
        // Transcript Analysis (40% weight) - Most important
        if let transcript = transcript, !transcript.isEmpty {
            let transcriptAnalysis = analyzeTranscriptDifficulty(transcript)
            totalScore += transcriptAnalysis.score * 0.4
            confidenceScore += transcriptAnalysis.confidence * 0.4
            reasoning.append(contentsOf: transcriptAnalysis.reasoning)
            keySkills.append(contentsOf: transcriptAnalysis.skills)
        } else {
            // Reweight other factors if no transcript available
            totalScore = (titleAnalysis.score * 0.4) + (descriptionAnalysis.score * 0.6)
            confidenceScore = (titleAnalysis.confidence * 0.4) + (descriptionAnalysis.confidence * 0.6)
            reasoning.append("Transcript analysis unavailable - using title and description analysis")
        }
        
        // Metadata Analysis (10% weight)
        let metadataAnalysis = analyzeMetadataDifficulty(duration: duration, channelTitle: channelTitle)
        totalScore += metadataAnalysis.score * 0.1
        confidenceScore += metadataAnalysis.confidence * 0.1
        reasoning.append(contentsOf: metadataAnalysis.reasoning)
        
        // Convert score to 1-5 scale
        let difficulty = max(1, min(5, Int(round(totalScore))))
        
        // Determine target audience
        let targetAudience = determineTargetAudience(score: totalScore)
        
        return DifficultyAnalysis(
            difficulty: difficulty,
            confidence: min(1.0, confidenceScore),
            targetAudience: targetAudience,
            keySkills: Array(Set(keySkills)), // Remove duplicates
            reasoning: reasoning
        )
    }
    
    // MARK: - Individual Analysis Components
    
    private struct AnalysisResult {
        let score: Double // 1.0-5.0
        let confidence: Double // 0.0-1.0
        let reasoning: [String]
        let skills: [String]
    }
    
    private func analyzeTitleDifficulty(_ title: String) -> AnalysisResult {
        let content = title.lowercased()
        var score: Double = 2.5 // Default to intermediate
        var confidence: Double = 0.6
        var reasoning: [String] = []
        var skills: [String] = []
        
        // Beginner indicators
        let beginnerKeywords = ["beginner", "basic", "simple", "easy", "introduction", "learn", "first time", "start"]
        let beginnerCount = beginnerKeywords.filter { content.contains($0) }.count
        
        // Intermediate indicators
        let intermediateKeywords = ["intermediate", "improve", "develop", "practice", "training", "drill"]
        let intermediateCount = intermediateKeywords.filter { content.contains($0) }.count
        
        // Advanced indicators
        let advancedKeywords = ["advanced", "professional", "expert", "master", "complex", "high level", "elite"]
        let advancedCount = advancedKeywords.filter { content.contains($0) }.count
        
        // Calculate score based on keyword presence
        if advancedCount > 0 {
            score = 4.0 + min(1.0, Double(advancedCount) * 0.3)
            confidence = 0.8
            reasoning.append("Advanced terminology in title")
        } else if beginnerCount > 0 {
            score = 1.5 + min(1.0, Double(beginnerCount) * 0.3)
            confidence = 0.8
            reasoning.append("Beginner terminology in title")
        } else if intermediateCount > 0 {
            score = 2.5 + min(1.0, Double(intermediateCount) * 0.2)
            confidence = 0.7
            reasoning.append("Intermediate terminology in title")
        }
        
        // Extract skills from title
        let skillKeywords = [
            "dribbling": "Dribbling", "passing": "Passing", "shooting": "Shooting",
            "control": "Ball Control", "juggling": "Ball Control", "finishing": "Shooting",
            "crossing": "Passing", "defending": "Defending", "goalkeeping": "Goalkeeping"
        ]
        
        for (keyword, skill) in skillKeywords {
            if content.contains(keyword) {
                skills.append(skill)
            }
        }
        
        return AnalysisResult(score: score, confidence: confidence, reasoning: reasoning, skills: skills)
    }
    
    private func analyzeDescriptionDifficulty(_ description: String) -> AnalysisResult {
        let content = description.lowercased()
        var score: Double = 2.5
        var confidence: Double = 0.7
        var reasoning: [String] = []
        var skills: [String] = []
        
        // More comprehensive analysis for descriptions
        let beginnerPhrases = [
            "for beginners", "new to soccer", "just starting", "basic technique",
            "fundamental", "first learn", "simple drill"
        ]
        
        let intermediatePhrases = [
            "build on", "next level", "improve your", "combine", "coordination",
            "timing", "intermediate players", "develop"
        ]
        
        let advancedPhrases = [
            "advanced technique", "professional level", "master this", "complex movement",
            "high intensity", "elite training", "tactical awareness"
        ]
        
        let beginnerMatches = beginnerPhrases.filter { content.contains($0) }.count
        let intermediateMatches = intermediatePhrases.filter { content.contains($0) }.count
        let advancedMatches = advancedPhrases.filter { content.contains($0) }.count
        
        // Calculate weighted score
        if advancedMatches > 0 {
            score = 4.0 + min(1.0, Double(advancedMatches) * 0.25)
            confidence = 0.85
            reasoning.append("Advanced concepts in description")
        } else if beginnerMatches > 0 {
            score = 1.5 + min(1.5, Double(beginnerMatches) * 0.25)
            confidence = 0.85
            reasoning.append("Beginner-focused description")
        } else if intermediateMatches > 0 {
            score = 2.5 + min(1.0, Double(intermediateMatches) * 0.2)
            confidence = 0.8
            reasoning.append("Intermediate concepts in description")
        }
        
        // Extract prerequisite complexity
        if content.contains("make sure you can") || content.contains("first master") {
            score += 0.5
            reasoning.append("Prerequisites mentioned")
        }
        
        // Extract skills
        let skillPatterns = [
            ("dribbl", "Dribbling"), ("pass", "Passing"), ("shoot", "Shooting"),
            ("control", "Ball Control"), ("defend", "Defending"), ("cross", "Passing"),
            ("finish", "Shooting"), ("agility", "Agility"), ("speed", "Speed")
        ]
        
        for (pattern, skill) in skillPatterns {
            if content.contains(pattern) {
                skills.append(skill)
            }
        }
        
        return AnalysisResult(score: score, confidence: confidence, reasoning: reasoning, skills: skills)
    }
    
    private func analyzeTranscriptDifficulty(_ transcript: String) -> AnalysisResult {
        let content = transcript.lowercased()
        var score: Double = 2.5
        let confidence: Double = 0.9 // Highest confidence since it's actual content
        var reasoning: [String] = []
        var skills: [String] = []
        
        // Analyze instruction complexity
        let instructionWords = content.components(separatedBy: " ")
        let wordCount = instructionWords.count
        
        // Technical terminology frequency
        let technicalTerms = [
            "technique", "biomechanics", "tactical", "positioning", "acceleration",
            "deceleration", "coordination", "proprioception", "muscle memory"
        ]
        let technicalCount = technicalTerms.filter { content.contains($0) }.count
        
        // Instruction complexity indicators
        let complexInstructions = [
            "simultaneously", "while maintaining", "as you", "make sure to",
            "coordinate", "timing is crucial", "precise", "exactly when"
        ]
        let complexCount = complexInstructions.filter { content.contains($0) }.count
        
        // Beginner language patterns
        let beginnerPatterns = [
            "let's start with", "very simple", "don't worry about", "just focus on",
            "take your time", "slowly", "basic movement"
        ]
        let beginnerCount = beginnerPatterns.filter { content.contains($0) }.count
        
        // Advanced language patterns
        let advancedPatterns = [
            "advanced players", "professional level", "must master", "quick decision",
            "under pressure", "high tempo", "elite technique"
        ]
        let advancedCount = advancedPatterns.filter { content.contains($0) }.count
        
        // Calculate base score from word count and complexity
        if wordCount > 1000 {
            score += 0.5 // Longer explanations = more complex
            reasoning.append("Detailed instruction content")
        }
        
        if technicalCount > 3 {
            score += 1.0
            reasoning.append("High technical terminology usage")
        } else if technicalCount > 1 {
            score += 0.5
            reasoning.append("Moderate technical terminology")
        }
        
        if complexCount > 5 {
            score += 1.0
            reasoning.append("Complex multi-step instructions")
        } else if complexCount > 2 {
            score += 0.5
            reasoning.append("Moderate instruction complexity")
        }
        
        // Adjust for explicit difficulty indicators
        if advancedCount > 0 {
            score += 1.5
            reasoning.append("Advanced concepts in instruction")
        } else if beginnerCount > 0 {
            score -= 1.0
            reasoning.append("Beginner-friendly instruction style")
        }
        
        // Count of sequential steps mentioned
        let stepIndicators = ["step", "first", "second", "third", "then", "next", "finally"]
        let stepCount = stepIndicators.filter { content.contains($0) }.count
        if stepCount > 8 {
            score += 0.5
            reasoning.append("Multi-step drill sequence")
        }
        
        // Extract skills from detailed content
        let detailedSkillPatterns = [
            ("first touch", "Ball Control"), ("weak foot", "Ambidexterity"),
            ("spatial awareness", "Vision"), ("decision making", "Decision Making"),
            ("body positioning", "Positioning"), ("tempo", "Game Intelligence")
        ]
        
        for (pattern, skill) in detailedSkillPatterns {
            if content.contains(pattern) {
                skills.append(skill)
            }
        }
        
        // Ensure score stays within bounds
        score = max(1.0, min(5.0, score))
        
        return AnalysisResult(score: score, confidence: confidence, reasoning: reasoning, skills: skills)
    }
    
    private func analyzeMetadataDifficulty(duration: Int, channelTitle: String) -> AnalysisResult {
        var score: Double = 2.5
        var confidenceLevel: Double = 0.4 // Lower confidence for metadata
        var reasoning: [String] = []
        let skills: [String] = []
        
        // Duration analysis
        if duration > 900 { // 15+ minutes
            score += 0.5
            reasoning.append("Extended duration suggests complex content")
        } else if duration < 180 { // Less than 3 minutes
            score -= 0.3
            reasoning.append("Short duration suggests simple drill")
        }
        
        // Channel authority analysis
        let professionalChannels = [
            "uefa", "fifa", "academy", "professional", "coach", "training center",
            "football club", "soccer club", "premier league", "la liga"
        ]
        
        let channelLower = channelTitle.lowercased()
        let isProfessional = professionalChannels.contains { channelLower.contains($0) }
        
        if isProfessional {
            score += 0.3
            confidenceLevel += 0.2
            reasoning.append("Professional/Academy channel")
        }
        
        return AnalysisResult(score: score, confidence: confidenceLevel, reasoning: reasoning, skills: skills)
    }
    
    private func determineTargetAudience(score: Double) -> String {
        switch score {
        case 1.0..<2.0: return "beginner"
        case 2.0..<3.5: return "intermediate"
        case 3.5..<4.5: return "advanced"
        default: return "expert"
        }
    }
    
    // MARK: - YouTube Transcript Integration
    
    private func fetchVideoTranscript(videoId: String, apiKey: String) async -> VideoTranscript? {
        do {
            // First, get available caption tracks
            let captionTracks = try await fetchCaptionTracks(videoId: videoId, apiKey: apiKey)
            
            // Find English caption track (prefer auto-generated for better availability)
            guard let captionTrack = findBestCaptionTrack(tracks: captionTracks) else {
                #if DEBUG
                print("üìù No suitable caption track found for video: \(videoId) (this is normal - most videos don't have public captions)")
                #endif
                return nil
            }
            
            // Download the caption content
            let transcriptText = try await downloadCaptionContent(captionUrl: captionTrack.url)
            
            return VideoTranscript(
                text: transcriptText,
                language: captionTrack.language,
                autoGenerated: captionTrack.kind == "asr"
            )
            
        } catch {
            // Gracefully handle caption access errors - this is expected for most videos
            if let httpError = error as? SimpleAPIError {
                switch httpError {
                case .networkError:
                    #if DEBUG
                    print("üìù Captions not accessible for video \(videoId) (privacy/auth restrictions)")
                    #endif
                default:
                    #if DEBUG
                    print("üìù Caption fetch failed for video \(videoId): \(error.localizedDescription)")
                    #endif
                }
            } else {
                #if DEBUG
                print("üìù Caption fetch failed for video \(videoId): \(error)")
                #endif
            }
            return nil
        }
    }
    
    private struct CaptionTrack {
        let id: String
        let url: String
        let language: String
        let kind: String // "asr" for auto-generated, "" for manual
    }
    
    private func fetchCaptionTracks(videoId: String, apiKey: String) async throws -> [CaptionTrack] {
        let urlString = "https://www.googleapis.com/youtube/v3/captions?part=snippet&videoId=\(videoId)&key=\(apiKey)"
        
        guard let url = URL(string: urlString) else {
            throw SimpleAPIError.invalidSearchQuery
        }
        
        let (data, response) = try await URLSession.shared.data(from: url)
        
        guard let httpResponse = response as? HTTPURLResponse else {
            throw SimpleAPIError.networkError
        }
        
        guard 200...299 ~= httpResponse.statusCode else {
            // Handle specific HTTP error codes for captions API
            switch httpResponse.statusCode {
            case 403:
                #if DEBUG
                print("‚ö†Ô∏è Captions API: Permission denied (403) - video \(videoId) may have restricted captions")
                #endif
            case 404:
                #if DEBUG
                print("‚ö†Ô∏è Captions API: Video \(videoId) not found (404)")
                #endif
            default:
                #if DEBUG
                print("‚ö†Ô∏è Captions API: HTTP error \(httpResponse.statusCode) for video \(videoId)")
                #endif
            }
            throw SimpleAPIError.networkError
        }
        
        guard let json = try JSONSerialization.jsonObject(with: data) as? [String: Any],
              let items = json["items"] as? [[String: Any]] else {
            return []
        }
        
        return items.compactMap { item in
            guard let id = item["id"] as? String,
                  let snippet = item["snippet"] as? [String: Any],
                  let language = snippet["language"] as? String else {
                return nil
            }
            
            // YouTube provides download URL in the snippet for public captions
            let downloadUrl = "https://www.googleapis.com/youtube/v3/captions/\(id)?tfmt=srt&key=\(apiKey)"
            
            return CaptionTrack(
                id: id,
                url: downloadUrl,
                language: language,
                kind: snippet["trackKind"] as? String ?? ""
            )
        }
    }
    
    private func findBestCaptionTrack(tracks: [CaptionTrack]) -> CaptionTrack? {
        // Priority: English manual > English auto > any manual > any auto
        
        // First try English manual captions
        if let englishManual = tracks.first(where: { $0.language == "en" && $0.kind != "asr" }) {
            return englishManual
        }
        
        // Then try English auto-generated
        if let englishAuto = tracks.first(where: { $0.language == "en" && $0.kind == "asr" }) {
            return englishAuto
        }
        
        // Then try any manual captions
        if let anyManual = tracks.first(where: { $0.kind != "asr" }) {
            return anyManual
        }
        
        // Finally, any auto-generated
        return tracks.first
    }
    
    private func downloadCaptionContent(captionUrl: String) async throws -> String {
        guard let url = URL(string: captionUrl) else {
            throw SimpleAPIError.invalidSearchQuery
        }
        
        let (data, response) = try await URLSession.shared.data(from: url)
        
        guard let httpResponse = response as? HTTPURLResponse,
              200...299 ~= httpResponse.statusCode else {
            throw SimpleAPIError.networkError
        }
        
        guard let content = String(data: data, encoding: .utf8) else {
            throw SimpleAPIError.parsingError
        }
        
        // Parse SRT format to extract just the text
        return parseSRTContent(content)
    }
    
    private func parseSRTContent(_ srtContent: String) -> String {
        let lines = srtContent.components(separatedBy: .newlines)
        var textLines: [String] = []
        var isTextLine = false
        
        for line in lines {
            let trimmedLine = line.trimmingCharacters(in: .whitespacesAndNewlines)
            
            // Skip empty lines
            if trimmedLine.isEmpty {
                isTextLine = false
                continue
            }
            
            // Skip sequence numbers (just digits)
            if Int(trimmedLine) != nil {
                continue
            }
            
            // Skip timestamp lines (contain -->)
            if trimmedLine.contains("-->") {
                isTextLine = true
                continue
            }
            
            // This is actual caption text
            if isTextLine {
                // Clean up HTML tags and formatting
                let cleanText = trimmedLine
                    .replacingOccurrences(of: "<[^>]+>", with: "", options: .regularExpression)
                    .replacingOccurrences(of: "&amp;", with: "&")
                    .replacingOccurrences(of: "&lt;", with: "<")
                    .replacingOccurrences(of: "&gt;", with: ">")
                
                if !cleanText.isEmpty {
                    textLines.append(cleanText)
                }
            }
        }
        
        return textLines.joined(separator: " ")
    }
    
    // MARK: - Enhanced Video Search with Transcript Analysis
    
    private func performEnhancedYouTubeSearch(query: String, apiKey: String, maxResults: Int) async throws -> [EnhancedYouTubeVideo] {
        // Set up cache expiration for next time
        clearExpiredCache()
        
        // First get basic video info
        let basicVideos = try await performYouTubeSearch(query: query, apiKey: apiKey, maxResults: maxResults)
        
        #if DEBUG
        
        print("üöÄ Processing \(basicVideos.count) videos concurrently for enhanced analysis...")
        
        
        #endif
        // Process all videos concurrently using TaskGroup with enhanced error handling
        let enhancedVideos = try await withThrowingTaskGroup(of: EnhancedYouTubeVideo?.self) { group in
            // Add a task for each video
            for video in basicVideos {
                group.addTask {
                    do {
                        return await self.processVideoEnhanced(video: video, apiKey: apiKey)
                    } catch {
                        #if DEBUG
                        print("‚ö†Ô∏è TaskGroup error for video \(video.title.prefix(30)): \(error)")
                        #endif
                        return nil
                    }
                }
            }
            
            // Collect results as they complete with error resilience
            var results: [EnhancedYouTubeVideo] = []
            var completedCount = 0
            let totalCount = basicVideos.count
            
            do {
                for try await enhancedVideo in group {
                    completedCount += 1
                    #if DEBUG
                    print("üìä Progress: \(completedCount)/\(totalCount) videos processed")
                    
                    #endif
                    if let video = enhancedVideo {
                        results.append(video)
                    }
                }
            } catch {
                #if DEBUG
                print("‚ö†Ô∏è TaskGroup collection error: \(error)")
                #endif
                // Continue with whatever results we have
            }
            
            return results
        }
        
        #if DEBUG
        
        print("‚úÖ Enhanced analysis complete for \(enhancedVideos.count) videos")
        
        #endif
        return enhancedVideos
    }
    
    // MARK: - Timeout and Retry Utilities
    
    private func withRetry<T>(maxAttempts: Int, operation: @escaping () async throws -> T) async throws -> T {
        var lastError: Error?
        
        for attempt in 1...maxAttempts {
            do {
                return try await operation()
            } catch {
                lastError = error
                #if DEBUG
                print("‚ö†Ô∏è Attempt \(attempt)/\(maxAttempts) failed: \(error)")
                
                #endif
                if attempt < maxAttempts {
                    // Exponential backoff: wait 0.5s, then 1s
                    let backoffTime = 0.5 * pow(2.0, Double(attempt - 1))
                    try await Task.sleep(nanoseconds: UInt64(backoffTime * 1_000_000_000))
                }
            }
        }
        
        throw lastError ?? TimeoutError.timeout
    }
    
    private func withTimeout<T>(seconds: TimeInterval, operation: @escaping () async throws -> T) async throws -> T {
        try await withThrowingTaskGroup(of: T.self) { group in
            group.addTask {
                try await operation()
            }
            
            group.addTask {
                try await Task.sleep(nanoseconds: UInt64(seconds * 1_000_000_000))
                throw TimeoutError.timeout
            }
            
            guard let result = try await group.next() else {
                throw TimeoutError.timeout
            }
            
            group.cancelAll()
            return result
        }
    }
    
    private func withTimeout<T>(seconds: TimeInterval, operation: @escaping () async -> T) async -> T? {
        do {
            return try await withThrowingTaskGroup(of: T?.self) { group in
                group.addTask {
                    await operation()
                }
                
                group.addTask {
                    try await Task.sleep(nanoseconds: UInt64(seconds * 1_000_000_000))
                    return nil
                }
                
                guard let result = try await group.next() else {
                    return nil
                }
                
                group.cancelAll()
                return result
            }
        } catch {
            return nil
        }
    }
    
    // Helper method to process individual video with error handling
    private func processVideoEnhanced(video: YouTubeVideo, apiKey: String) async -> EnhancedYouTubeVideo? {
        // Circuit breaker: skip processing if too many consecutive failures
        if consecutiveFailures >= maxConsecutiveFailures {
            #if DEBUG
            print("üö® Circuit breaker activated - skipping video processing due to \(consecutiveFailures) consecutive failures")
            #endif
            return createFallbackVideo(video: video)
        }
        do {
            #if DEBUG
            print("üîç Processing video: \(video.title.prefix(50))...")
            
            #endif
            // Get video details with caching
            let videoDetails = try await getCachedVideoDetails(videoId: video.videoId, apiKey: apiKey)
            
            // Fetch transcript with caching
            let transcript = await getCachedTranscript(videoId: video.videoId, apiKey: apiKey)
            
            // Perform comprehensive difficulty analysis
            let difficultyAnalysis = analyzeVideoDifficultyComprehensive(
                title: video.title,
                description: videoDetails?.description ?? "",
                transcript: transcript?.text,
                duration: videoDetails?.duration ?? 300,
                channelTitle: video.channel
            )
            
            let enhancedVideo = EnhancedYouTubeVideo(
                videoId: video.videoId,
                title: video.title,
                channel: video.channel,
                description: videoDetails?.description ?? video.title,
                duration: videoDetails?.duration ?? 300,
                transcript: transcript,
                difficultyAnalysis: difficultyAnalysis
            )
            
            #if DEBUG
            
            print("‚úÖ Completed: \(video.title.prefix(30))...")
            
            #endif
            consecutiveFailures = 0  // Reset failure count on success
            return enhancedVideo
            
        } catch {
            #if DEBUG
            print("‚ö†Ô∏è Failed to process video \(video.title.prefix(30)): \(error)")
            #endif
            consecutiveFailures += 1
            
            return createFallbackVideo(video: video)
        }
    }
    
    // Create a fallback video with basic analysis when processing fails
    private func createFallbackVideo(video: YouTubeVideo) -> EnhancedYouTubeVideo {
        #if DEBUG
        print("üîÑ Creating fallback video for: \(video.title.prefix(30))...")
        
        #endif
        let basicAnalysis = analyzeVideoDifficultyComprehensive(
            title: video.title,
            description: "",
            transcript: nil,
            duration: 300,
            channelTitle: video.channel
        )
        
        return EnhancedYouTubeVideo(
            videoId: video.videoId,
            title: video.title,
            channel: video.channel,
            description: video.title,
            duration: 300,
            transcript: nil,
            difficultyAnalysis: basicAnalysis
        )
    }
    
    // MARK: - Caching Methods
    
    private func getCachedVideoDetails(videoId: String, apiKey: String) async throws -> EnhancedVideoDetails? {
        // Check cache first
        if let cachedDetails = videoDetailsCache[videoId] {
            #if DEBUG
            print("üìÇ Using cached video details for: \(videoId)")
            #endif
            return cachedDetails
        }
        
        // Fetch from API with retry and timeout
        let details = try await withRetry(maxAttempts: 2) {
            try await self.withTimeout(seconds: 10) {
                try await self.fetchVideoDetails(videoId: videoId, apiKey: apiKey)
            }
        }
        
        // Cache the result
        videoDetailsCache[videoId] = details
        #if DEBUG
        print("üíæ Cached video details for: \(videoId)")
        
        #endif
        return details
    }
    
    private func getCachedTranscript(videoId: String, apiKey: String) async -> VideoTranscript? {
        // Check cache first
        if let cachedTranscript = transcriptCache[videoId] {
            #if DEBUG
            print("üìÇ Using cached transcript for: \(videoId)")
            #endif
            return cachedTranscript
        }
        
        // Fetch from API with timeout (no retry to avoid quota waste)
        let transcript = await self.withTimeout(seconds: 5) {
            await self.fetchVideoTranscript(videoId: videoId, apiKey: apiKey)
        } ?? nil
        
        // Cache the result (even if nil to avoid repeated failed requests)
        transcriptCache[videoId] = transcript
        if transcript != nil {
            #if DEBUG
            print("üíæ Cached transcript for: \(videoId)")
            #endif
        }
        
        return transcript
    }
    
    private func clearExpiredCache() {
        // Simple cache clearing - clear all after expiration time
        // In a production app, you'd track individual timestamps
        DispatchQueue.main.asyncAfter(deadline: .now() + cacheExpirationTime) {
            self.videoDetailsCache.removeAll()
            self.transcriptCache.removeAll()
            #if DEBUG
            print("üßπ Cleared expired cache")
            #endif
        }
    }
    
    // Using EnhancedVideoDetails and EnhancedYouTubeVideo from YouTubeModels.swift
    
    private func fetchVideoDetails(videoId: String, apiKey: String) async throws -> EnhancedVideoDetails {
        let urlString = "https://www.googleapis.com/youtube/v3/videos?part=snippet,contentDetails,statistics&id=\(videoId)&key=\(apiKey)"
        
        guard let url = URL(string: urlString) else {
            throw SimpleAPIError.invalidSearchQuery
        }
        
        let (data, response) = try await URLSession.shared.data(from: url)
        
        guard let httpResponse = response as? HTTPURLResponse,
              200...299 ~= httpResponse.statusCode else {
            throw SimpleAPIError.networkError
        }
        
        guard let json = try JSONSerialization.jsonObject(with: data) as? [String: Any],
              let items = json["items"] as? [[String: Any]],
              let item = items.first,
              let snippet = item["snippet"] as? [String: Any],
              let contentDetails = item["contentDetails"] as? [String: Any],
              let statistics = item["statistics"] as? [String: Any] else {
            throw SimpleAPIError.parsingError
        }
        
        let description = snippet["description"] as? String ?? ""
        let durationISO = contentDetails["duration"] as? String ?? "PT0S"
        let viewCountString = statistics["viewCount"] as? String ?? "0"
        let publishedAt = snippet["publishedAt"] as? String ?? ""
        
        return EnhancedVideoDetails(
            description: description,
            duration: parseISO8601Duration(durationISO),
            viewCount: Int(viewCountString) ?? 0,
            publishedAt: publishedAt
        )
    }
    
    private func parseISO8601Duration(_ duration: String) -> Int {
        // Parse YouTube's PT#M#S format to seconds
        let pattern = "PT(?:(\\d+)M)?(?:(\\d+)S)?"
        guard let regex = try? NSRegularExpression(pattern: pattern) else {
            return 0
        }
        
        let range = NSRange(location: 0, length: duration.utf16.count)
        guard let match = regex.firstMatch(in: duration, range: range) else {
            return 0
        }
        
        var totalSeconds = 0
        
        // Extract minutes
        if match.range(at: 1).location != NSNotFound {
            let minutesRange = match.range(at: 1)
            let minutesString = (duration as NSString).substring(with: minutesRange)
            if let minutes = Int(minutesString) {
                totalSeconds += minutes * 60
            }
        }
        
        // Extract seconds
        if match.range(at: 2).location != NSNotFound {
            let secondsRange = match.range(at: 2)
            let secondsString = (duration as NSString).substring(with: secondsRange)
            if let seconds = Int(secondsString) {
                totalSeconds += seconds
            }
        }
        
        return totalSeconds
    }

    private func performYouTubeSearch(query: String, apiKey: String, maxResults: Int) async throws -> [YouTubeVideo] {
        let urlString = "https://www.googleapis.com/youtube/v3/search?part=snippet&maxResults=\(maxResults)&q=\(query.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed) ?? "")&type=video&key=\(apiKey)"
        
        guard let url = URL(string: urlString) else {
            #if DEBUG
            print("‚ùå Invalid URL for YouTube search")
            #endif
            return []
        }
        
        do {
            let (data, response) = try await URLSession.shared.data(from: url)
            
            guard let httpResponse = response as? HTTPURLResponse else {
                #if DEBUG
                print("‚ùå Invalid HTTP response")
                #endif
                return []
            }
            
            guard 200...299 ~= httpResponse.statusCode else {
                #if DEBUG
                print("‚ùå YouTube API Error - Status Code: \(httpResponse.statusCode)")
                #endif
                if let errorData = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
                   let error = errorData["error"] as? [String: Any],
                   let message = error["message"] as? String {
                    #if DEBUG
                    print("‚ùå YouTube API Error Message: \(message)")
                    #endif
                }
                return []
            }
            
            guard let json = try JSONSerialization.jsonObject(with: data) as? [String: Any],
                  let items = json["items"] as? [[String: Any]] else {
                #if DEBUG
                print("‚ùå Failed to parse YouTube response")
                #endif
                return []
            }
            
            return items.compactMap { item in
                guard let id = item["id"] as? [String: Any],
                      let videoId = id["videoId"] as? String,
                      let snippet = item["snippet"] as? [String: Any],
                      let title = snippet["title"] as? String,
                      let channelTitle = snippet["channelTitle"] as? String else {
                    return nil
                }
                
                return YouTubeVideo(
                    videoId: videoId,
                    title: title,
                    channel: channelTitle,
                    duration: "N/A"
                )
            }
        } catch {
            #if DEBUG
            print("‚ùå Network error: \(error)")
            #endif
            return []
        }
    }
    
    // MARK: - Smart Recommendation System
    
    struct DrillRecommendation {
        let exercise: Exercise
        let reason: String
        let priority: Int
        let category: RecommendationCategory
        let confidenceScore: Double
        let physicalIndicators: PhysicalIndicators
    }
    
    struct PhysicalIndicators {
        let intensity: PhysicalIntensity
        let duration: PhysicalDuration
        let physicalDemands: [PhysicalDemand]
        let heartRateZone: HeartRateZone
        let recoveryTime: RecoveryTime
    }
    
    enum PhysicalIntensity: Int, CaseIterable {
        case low = 1, moderate = 2, high = 3, veryHigh = 4, maximal = 5
        
        var displayName: String {
            switch self {
            case .low: return "Low"
            case .moderate: return "Moderate"
            case .high: return "High"
            case .veryHigh: return "Very High"
            case .maximal: return "Maximal"
            }
        }
        
        var color: String {
            switch self {
            case .low: return "green"
            case .moderate: return "yellow"
            case .high: return "orange"
            case .veryHigh: return "red"
            case .maximal: return "purple"
            }
        }
    }
    
    enum PhysicalDuration: CaseIterable {
        case short, medium, long, extended
        
        var displayName: String {
            switch self {
            case .short: return "5-15 min"
            case .medium: return "15-30 min"
            case .long: return "30-60 min"
            case .extended: return "60+ min"
            }
        }
        
        var estimatedMinutes: Int {
            switch self {
            case .short: return 10
            case .medium: return 22
            case .long: return 45
            case .extended: return 75
            }
        }
    }
    
    enum PhysicalDemand: String, CaseIterable {
        case cardio = "Cardio"
        case strength = "Strength"
        case agility = "Agility"
        case coordination = "Coordination"
        case balance = "Balance"
        case flexibility = "Flexibility"
        case power = "Power"
        case endurance = "Endurance"
        case speed = "Speed"
        case reaction = "Reaction Time"
        
        var icon: String {
            switch self {
            case .cardio: return "heart.fill"
            case .strength: return "dumbbell.fill"
            case .agility: return "figure.run"
            case .coordination: return "eye.fill"
            case .balance: return "figure.stand"
            case .flexibility: return "figure.yoga"
            case .power: return "bolt.fill"
            case .endurance: return "clock.fill"
            case .speed: return "speedometer"
            case .reaction: return "timer"
            }
        }
    }
    
    enum HeartRateZone: Int, CaseIterable {
        case recovery = 1, aerobic = 2, threshold = 3, anaerobic = 4, neuromuscular = 5
        
        var displayName: String {
            switch self {
            case .recovery: return "Zone 1 (Recovery)"
            case .aerobic: return "Zone 2 (Aerobic)"
            case .threshold: return "Zone 3 (Threshold)"
            case .anaerobic: return "Zone 4 (Anaerobic)"
            case .neuromuscular: return "Zone 5 (Neuromuscular)"
            }
        }
        
        var shortName: String {
            switch self {
            case .recovery: return "Z1"
            case .aerobic: return "Z2"
            case .threshold: return "Z3"
            case .anaerobic: return "Z4"
            case .neuromuscular: return "Z5"
            }
        }
        
        var percentageRange: String {
            switch self {
            case .recovery: return "50-60%"
            case .aerobic: return "60-70%"
            case .threshold: return "70-80%"
            case .anaerobic: return "80-90%"
            case .neuromuscular: return "90-100%"
            }
        }
    }
    
    enum RecoveryTime: CaseIterable {
        case minimal, short, moderate, long, extended
        
        var displayName: String {
            switch self {
            case .minimal: return "0-30 min"
            case .short: return "30 min - 2 hrs"
            case .moderate: return "2-6 hrs"
            case .long: return "6-24 hrs"
            case .extended: return "24+ hrs"
            }
        }
        
        var recommendation: String {
            switch self {
            case .minimal: return "Ready for next drill"
            case .short: return "Light activity recommended"
            case .moderate: return "Active recovery needed"
            case .long: return "Rest or light training"
            case .extended: return "Full recovery day needed"
            }
        }
    }
    
    enum RecommendationCategory {
        case skillGap
        case difficultyProgression
        case varietyBalance
        case repeatSuccess
        case complementarySkill
    }
    
    func getSmartRecommendations(for player: Player, limit: Int = 5) -> [DrillRecommendation] {
        #if DEBUG
        print("üß† Generating smart recommendations for \(player.name ?? "Unknown")")
        
        #endif
        // Ensure we're getting training history only for this specific player
        let trainingHistory = analyzeTrainingHistory(for: player)
        let skillGaps = identifySkillGaps(from: trainingHistory)
        let difficultyPattern = analyzeDifficultyProgression(from: trainingHistory)
        
        var recommendations: [DrillRecommendation] = []
        var globalUsedExercises: Set<String> = []
        
        // 1. Skill Gap Recommendations (Highest Priority)
        let skillGapRecs = generateSkillGapRecommendations(
            for: player,
            skillGaps: skillGaps,
            trainingHistory: trainingHistory,
            usedExercises: &globalUsedExercises
        )
        recommendations.append(contentsOf: skillGapRecs)
        
        // 2. Difficulty Progression Recommendations
        let progressionRecs = generateDifficultyProgressionRecommendations(
            for: player,
            currentLevel: difficultyPattern.averageDifficulty,
            performancePattern: difficultyPattern.performanceByDifficulty,
            trainingHistory: trainingHistory,
            usedExercises: &globalUsedExercises
        )
        recommendations.append(contentsOf: progressionRecs)
        
        // 3. Variety and Balance Recommendations
        let varietyRecs = generateVarietyRecommendations(
            for: player,
            trainingHistory: trainingHistory,
            usedExercises: &globalUsedExercises
        )
        recommendations.append(contentsOf: varietyRecs)
        
        // 4. Success Pattern Recommendations
        let successRecs = generateSuccessPatternRecommendations(
            for: player,
            trainingHistory: trainingHistory,
            usedExercises: &globalUsedExercises
        )
        recommendations.append(contentsOf: successRecs)
        
        // Sort by priority and confidence, then limit results
        let sortedRecommendations = recommendations
            .sorted { first, second in
                if first.priority != second.priority {
                    return first.priority < second.priority
                }
                return first.confidenceScore > second.confidenceScore
            }
            .prefix(limit)
        
        #if DEBUG
        
        print("‚úÖ Generated \(sortedRecommendations.count) unique smart recommendations")
        
        #endif
        #if DEBUG
        print("üìù Used exercises: \(globalUsedExercises)")
        #endif
        return Array(sortedRecommendations)
    }
    
    private func removeDuplicateRecommendations(_ recommendations: [DrillRecommendation]) -> [DrillRecommendation] {
        var uniqueRecommendations: [DrillRecommendation] = []
        var seenExerciseNames: Set<String> = []
        
        for recommendation in recommendations {
            let exerciseName = recommendation.exercise.name ?? ""
            
            if !seenExerciseNames.contains(exerciseName) {
                seenExerciseNames.insert(exerciseName)
                uniqueRecommendations.append(recommendation)
            } else {
                #if DEBUG
                print("üîÑ Skipping duplicate recommendation: \(exerciseName)")
                #endif
            }
        }
        
        #if DEBUG
        
        print("üìä Filtered \(recommendations.count) recommendations to \(uniqueRecommendations.count) unique ones")
        
        #endif
        return uniqueRecommendations
    }
    
    private struct TrainingHistory {
        let totalSessions: Int
        let recentSessions: [TrainingSession] // Last 30 sessions for analysis
        let allSessions: [TrainingSession] // All sessions for accurate date calculations
        let skillFrequency: [String: Int]
        let categoryFrequency: [String: Int]
        let averagePerformance: Double
        let skillPerformance: [String: Double]
        let lastTrainingDate: Date?

        // NEW: Recent performance tracking
        let recentSkillPerformance: [String: Double] // Last 14 days
        let veryRecentSkillPerformance: [String: Double] // Last 7 days
        let recentExercises: Set<String> // Exercises done in last 3 days
        let poorPerformanceSkills: [String] // Skills with <3.0 avg in last 14 days
    }
    
    private struct DifficultyPattern {
        let averageDifficulty: Double
        let performanceByDifficulty: [Int: Double]
        let readyForProgression: Bool
        let strugglingDifficulties: [Int]
    }
    
    private func analyzeTrainingHistory(for player: Player) -> TrainingHistory {
        guard let sessionsSet = player.sessions as? Set<TrainingSession> else {
            #if DEBUG
            print("‚ö†Ô∏è No training sessions found for player \(player.name ?? "Unknown") (UID: \(player.firebaseUID ?? "Unknown"))")
            #endif
            return TrainingHistory(
                totalSessions: 0,
                recentSessions: [],
                allSessions: [],
                skillFrequency: [:],
                categoryFrequency: [:],
                averagePerformance: 0,
                skillPerformance: [:],
                lastTrainingDate: nil,
                recentSkillPerformance: [:],
                veryRecentSkillPerformance: [:],
                recentExercises: [],
                poorPerformanceSkills: []
            )
        }
        
        #if DEBUG
        
        print("üìä Analyzing training history for player \(player.name ?? "Unknown") (UID: \(player.firebaseUID ?? "Unknown")) - found \(sessionsSet.count) sessions")
        
        
        #endif
        let sessions = Array(sessionsSet).sorted {
            ($0.date ?? Date.distantPast) > ($1.date ?? Date.distantPast)
        }
        let recentSessions = Array(sessions.prefix(30))

        // Calculate time boundaries
        let now = Date()
        let threeDaysAgo = Calendar.current.date(byAdding: .day, value: -3, to: now) ?? now
        let sevenDaysAgo = Calendar.current.date(byAdding: .day, value: -7, to: now) ?? now
        let fourteenDaysAgo = Calendar.current.date(byAdding: .day, value: -14, to: now) ?? now

        var skillFrequency: [String: Int] = [:]
        var categoryFrequency: [String: Int] = [:]
        var skillPerformanceData: [String: [Double]] = [:]
        var totalPerformance: [Double] = []

        // NEW: Recent performance tracking
        var recentSkillPerformanceData: [String: [Double]] = [:] // Last 14 days
        var veryRecentSkillPerformanceData: [String: [Double]] = [:] // Last 7 days
        var recentExerciseNames: Set<String> = [] // Last 3 days

        for session in recentSessions {
            totalPerformance.append(Double(session.overallRating))
            let sessionDate = session.date ?? Date.distantPast

            if let exercisesSet = session.exercises as? Set<SessionExercise> {
                for sessionExercise in exercisesSet {
                    if let exercise = sessionExercise.exercise {
                        // Count category frequency
                        let category = exercise.category ?? "Unknown"
                        categoryFrequency[category, default: 0] += 1

                        // Track exercises done in last 3 days
                        if sessionDate >= threeDaysAgo {
                            recentExerciseNames.insert(exercise.name ?? "")
                        }

                        // Count skill frequency and track performance
                        if let skills = exercise.targetSkills {
                            for skill in skills {
                                skillFrequency[skill, default: 0] += 1
                                let performance = Double(sessionExercise.performanceRating)
                                skillPerformanceData[skill, default: []].append(performance)

                                // Track recent performance (14 days)
                                if sessionDate >= fourteenDaysAgo {
                                    recentSkillPerformanceData[skill, default: []].append(performance)
                                }

                                // Track very recent performance (7 days)
                                if sessionDate >= sevenDaysAgo {
                                    veryRecentSkillPerformanceData[skill, default: []].append(performance)
                                }
                            }
                        }
                    }
                }
            }
        }

        // Calculate average skill performance
        let skillPerformance = skillPerformanceData.mapValues { performances in
            performances.reduce(0, +) / Double(performances.count)
        }

        // Calculate recent skill performance (14 days)
        let recentSkillPerformance = recentSkillPerformanceData.mapValues { performances in
            performances.reduce(0, +) / Double(performances.count)
        }

        // Calculate very recent skill performance (7 days)
        let veryRecentSkillPerformance = veryRecentSkillPerformanceData.mapValues { performances in
            performances.reduce(0, +) / Double(performances.count)
        }

        // Identify skills with poor recent performance (<3.0 in last 14 days)
        let poorPerformanceSkills = recentSkillPerformance.filter { $0.value < 3.0 }.map { $0.key }

        let averagePerformance = totalPerformance.isEmpty ? 0 :
            totalPerformance.reduce(0, +) / Double(totalPerformance.count)

        return TrainingHistory(
            totalSessions: sessions.count,
            recentSessions: recentSessions,
            allSessions: sessions,
            skillFrequency: skillFrequency,
            categoryFrequency: categoryFrequency,
            averagePerformance: averagePerformance,
            skillPerformance: skillPerformance,
            lastTrainingDate: sessions.first?.date,
            recentSkillPerformance: recentSkillPerformance,
            veryRecentSkillPerformance: veryRecentSkillPerformance,
            recentExercises: recentExerciseNames,
            poorPerformanceSkills: poorPerformanceSkills
        )
    }
    
    private func identifySkillGaps(from history: TrainingHistory) -> [String] {
        let allSkills = ["Ball Control", "Passing", "Shooting", "Dribbling", 
                        "Defending", "Speed", "Agility", "Endurance", "Vision", "Decision Making"]
        
        var gaps: [String] = []
        
        for skill in allSkills {
            let frequency = history.skillFrequency[skill] ?? 0
            let performance = history.skillPerformance[skill] ?? 0
            
            // Identify as gap if: rarely practiced OR poor performance
            if frequency < 2 || performance < 3.0 {
                gaps.append(skill)
            }
        }
        
        return gaps
    }
    
    private func analyzeDifficultyProgression(from history: TrainingHistory) -> DifficultyPattern {
        var difficultyPerformance: [Int: [Double]] = [:]
        var totalDifficulties: [Double] = []
        
        for session in history.recentSessions {
            if let exercisesSet = session.exercises as? Set<SessionExercise> {
                for sessionExercise in exercisesSet {
                    if let exercise = sessionExercise.exercise {
                        let difficulty = Int(exercise.difficulty)
                        let performance = Double(sessionExercise.performanceRating)
                        
                        difficultyPerformance[difficulty, default: []].append(performance)
                        totalDifficulties.append(Double(difficulty))
                    }
                }
            }
        }
        
        let averageDifficulty = totalDifficulties.isEmpty ? 2.0 :
            totalDifficulties.reduce(0, +) / Double(totalDifficulties.count)
        
        let performanceByDifficulty = difficultyPerformance.mapValues { performances in
            performances.reduce(0, +) / Double(performances.count)
        }
        
        // Determine if ready for progression (performing well at current level)
        let currentLevelPerformance = performanceByDifficulty[Int(averageDifficulty)] ?? 0
        let readyForProgression = currentLevelPerformance >= 4.0
        
        // Find struggling difficulties
        let strugglingDifficulties = performanceByDifficulty.compactMap { difficulty, performance in
            performance < 3.0 ? difficulty : nil
        }
        
        return DifficultyPattern(
            averageDifficulty: averageDifficulty,
            performanceByDifficulty: performanceByDifficulty,
            readyForProgression: readyForProgression,
            strugglingDifficulties: strugglingDifficulties
        )
    }
    
    // MARK: - Dynamic Description Generation
    
    private func generateSkillGapDescription(
        for player: Player,
        skill: String,
        trainingHistory: TrainingHistory
    ) -> String {
        let gapFrequency = trainingHistory.skillFrequency[skill] ?? 0
        let totalSessions = trainingHistory.totalSessions
        let skillPerformance = trainingHistory.skillPerformance[skill] ?? 3.0
        let position = player.position?.lowercased() ?? ""
        let _ = player.name ?? "Player"

        // NEW: Check recent performance (last 14 days)
        let recentPerformance = trainingHistory.recentSkillPerformance[skill]
        let veryRecentPerformance = trainingHistory.veryRecentSkillPerformance[skill]

        // Calculate days since last practice
        let daysSinceLastPractice = calculateDaysSinceSkillPractice(skill: skill, sessions: trainingHistory.allSessions)

        // Position-specific importance
        let positionContext = getPositionContext(for: skill, position: position)

        // PRIORITY 1: Recent poor performance (last 14 days)
        if let recentPerf = recentPerformance, recentPerf < 3.0 {
            let perfPercent = Int(recentPerf * 20)
            return "Your recent \(skill.lowercased()) sessions averaged \(String(format: "%.1f", recentPerf))/5 stars (\(perfPercent)%) - let's improve that together!"
        }

        // PRIORITY 2: Very recent struggle (last 7 days)
        if let veryRecentPerf = veryRecentPerformance, veryRecentPerf < 3.5 {
            return "This past week, your \(skill.lowercased()) work showed room to grow (avg: \(String(format: "%.1f", veryRecentPerf))/5). Perfect time to focus on it!"
        }

        // PRIORITY 3: Never practiced this skill
        if gapFrequency == 0 && totalSessions > 3 {
            let templates = [
                "Time to explore \(skill.lowercased()) - it's a gap in your training that could unlock new potential!",
                "\(skill) hasn't appeared in your training yet. \(positionContext)",
                "Let's add \(skill.lowercased()) to your skillset - every complete player needs this foundation."
            ]
            let experienceLevel = player.experienceLevel?.lowercased() ?? "intermediate"
            let templateIndex = experienceLevel == "beginner" ? 2 : (totalSessions > 10 ? 0 : 1)
            return templates[templateIndex]
        }

        // PRIORITY 4: Not practiced in 2+ weeks
        if daysSinceLastPractice > 14 {
            if daysSinceLastPractice <= 30 {
                return "It's been \(daysSinceLastPractice) days since your last \(skill.lowercased()) session - let's keep those skills sharp!"
            } else {
                return "Your \(skill.lowercased()) skills need attention - you haven't practiced in over \(daysSinceLastPractice / 7) weeks."
            }
        }

        // PRIORITY 5: Overall poor performance
        if skillPerformance < 3.0 {
            let templates = [
                "Your \(skill.lowercased()) showed room for improvement (overall avg: \(String(format: "%.1f", skillPerformance))/5). Let's work on it!",
                "\(skill) could use some focus - your sessions averaged \(String(format: "%.0f", skillPerformance * 20))% performance.",
                "Time to boost your \(skill.lowercased()) - it's currently your biggest opportunity area."
            ]
            let templateIndex = skillPerformance < 2.0 ? 2 : (skillPerformance < 2.5 ? 1 : 0)
            return templates[templateIndex]
        }

        // PRIORITY 6: General skill gap
        let templates = [
            "Balance your training with some \(skill.lowercased()) work - you've been focusing elsewhere lately.",
            "\(skill) deserves more attention in your routine. \(positionContext)",
            "Round out your skillset with focused \(skill.lowercased()) practice."
        ]
        let templateIndex = gapFrequency == 0 ? 2 : (position.isEmpty ? 0 : 1)
        return templates[templateIndex]
    }
    
    private func generateFoundationDescription(
        for player: Player,
        currentLevel: Double,
        easierLevel: Int,
        trainingHistory: TrainingHistory
    ) -> String {
        let currentPerformance = trainingHistory.averagePerformance
        let experienceLevel = player.experienceLevel?.lowercased() ?? "intermediate"
        
        let templates = [
            "Your recent level \(Int(currentLevel)) sessions averaged \(String(format: "%.0f", currentPerformance * 20))% - let's master level \(easierLevel) fundamentals first.",
            "Building solid level \(easierLevel) foundations will make those advanced techniques much easier to master.",
            "Every pro started with perfect fundamentals. Let's nail level \(easierLevel) before advancing!",
            "Strong basics lead to breakthrough moments - level \(easierLevel) drills will set you up for success."
        ]
        
        if experienceLevel == "beginner" {
            return "Perfect! Level \(easierLevel) drills are ideal for building your soccer foundation step by step."
        }
        
        // Select template based on performance level
        let templateIndex = currentPerformance < 0.6 ? 0 : (currentPerformance < 0.7 ? 3 : 1)
        return templates[templateIndex]
    }
    
    private func generateProgressionDescription(
        for player: Player,
        currentLevel: Double,
        performance: Double,
        trainingHistory: TrainingHistory
    ) -> String {
        let recentSessions = trainingHistory.recentSessions.count
        let roleModel = player.playerRoleModel ?? ""
        
        let templates = [
            "Impressive! Your level \(Int(currentLevel)) sessions are averaging \(String(format: "%.0f", performance * 20))% - ready for the next challenge?",
            "\(recentSessions) strong sessions in a row at level \(Int(currentLevel)) - time to test your limits!",
            "Your consistency at this level is paying off. Let's see what you can do with tougher challenges!",
            "Level \(Int(currentLevel)) is becoming your comfort zone - that's when real growth begins!"
        ]
        
        if !roleModel.isEmpty {
            return "Like \(roleModel), push your boundaries! Your level \(Int(currentLevel)) mastery shows you're ready for advanced techniques."
        }
        
        // Select template based on performance and recent activity
        let templateIndex = performance > 0.85 ? 0 : (recentSessions >= 5 ? 1 : (performance > 0.75 ? 2 : 3))
        return templates[templateIndex]
    }
    
    private func generateVarietyDescription(
        for player: Player,
        category: String,
        trainingHistory: TrainingHistory
    ) -> String {
        let categoryFreq = trainingHistory.categoryFrequency[category] ?? 0
        let totalSessions = trainingHistory.totalSessions
        let position = player.position?.lowercased() ?? ""
        let playingStyle = player.playingStyle?.lowercased() ?? ""
        
        // Calculate how underrepresented this category is
        let idealFrequency = totalSessions / 4 // Should be roughly 25% of training
        let deficit = max(0, idealFrequency - categoryFreq)
        
        if deficit >= idealFrequency / 2 { // Severely lacking
            let templates = [
                "Your training is heavy on other areas - let's balance it out with \(category.lowercased()) work.",
                "Time to mix things up! \(category) training will round out your skillset perfectly.",
                "You've been avoiding \(category.lowercased()) - let's change that and become more complete."
            ]
            // Select template based on deficit severity
            let templateIndex = deficit >= Int(Double(idealFrequency) * 0.75) ? 2 : (totalSessions > 15 ? 1 : 0)
            return templates[templateIndex]
        } else { // General variety
            let templates = [
                "Add some spice to your routine with \(category.lowercased()) training!",
                "Variety keeps training fresh - \(category.lowercased()) work will complement your recent sessions.",
                "Well-rounded players excel in all areas. Time for some \(category.lowercased()) focus!"
            ]
            
            // Position-specific variety suggestions
            if position == "midfielder" && category.lowercased().contains("defensive") {
                return "As a midfielder, defensive awareness is crucial - this drill develops that sixth sense!"
            } else if position == "striker" && category.lowercased().contains("shooting") {
                return "Goal scorers never stop practicing! Perfect your finishing with this \(category.lowercased()) drill."
            }
            
            // Select template based on training frequency
            let templateIndex = totalSessions < 5 ? 0 : (categoryFreq == 0 ? 2 : 1)
            return templates[templateIndex]
        }
    }
    
    private func generateSuccessDescription(
        for player: Player,
        strongSkill: String,
        skillPerformance: Double,
        trainingHistory: TrainingHistory
    ) -> String {
        let roleModel = player.playerRoleModel ?? ""
        let performancePercent = Int(skillPerformance * 20)
        
        let templates = [
            "\(strongSkill) is clearly your strength (\(performancePercent)% avg.) - let's make it legendary!",
            "You're naturally gifted at \(strongSkill.lowercased()) - here's an advanced drill to push it further.",
            "Double down on what's working! Your \(strongSkill.lowercased()) skills are already impressive.",
            "Your \(strongSkill.lowercased()) technique stands out - time to perfect it with advanced challenges."
        ]
        
        if !roleModel.isEmpty && (strongSkill.lowercased().contains("dribbling") || strongSkill.lowercased().contains("ball control")) {
            return "Like \(roleModel), your \(strongSkill.lowercased()) is exceptional - let's make it your signature move!"
        }
        
        // Select template based on performance level
        let templateIndex = performancePercent >= 90 ? 0 : (performancePercent >= 80 ? 3 : (performancePercent >= 70 ? 1 : 2))
        return templates[templateIndex]
    }
    
    // Helper functions
    private func getPositionContext(for skill: String, position: String) -> String {
        switch (skill.lowercased(), position) {
        case (let s, "midfielder") where s.contains("passing"):
            return "As a midfielder, precise passing is the foundation of your game."
        case (let s, "striker") where s.contains("shooting"):
            return "Goal scoring is what strikers live for - this skill is essential."
        case (let s, "defender") where s.contains("defending"):
            return "Defensive skills are your specialty - perfect them!"
        case (let s, "goalkeeper") where s.contains("handling"):
            return "Shot stopping ability separates good keepers from great ones."
        default:
            return "Every complete player needs strong fundamentals in all areas."
        }
    }

    private func mapExperienceToLevel(_ experience: String) -> Int {
        switch experience.lowercased() {
        case "beginner", "novice":
            return 1
        case "intermediate":
            return 3
        case "advanced":
            return 4
        case "expert", "professional":
            return 5
        default:
            return 3 // Default to intermediate
        }
    }

    private func calculateDaysSinceSkillPractice(skill: String, sessions: [TrainingSession]) -> Int {
        let calendar = Calendar.current
        let now = Date()
        
        // Find most recent session with this skill
        for session in sessions.sorted(by: { ($0.date ?? Date.distantPast) > ($1.date ?? Date.distantPast) }) {
            if let exercises = session.exercises as? Set<Exercise> {
                for exercise in exercises {
                    if exercise.targetSkills?.contains(skill) == true {
                        if let sessionDate = session.date {
                            return calendar.dateComponents([.day], from: sessionDate, to: now).day ?? 0
                        }
                    }
                }
            }
        }
        return 30 // Default to 30 days if not found
    }
    
    private func generateSkillGapRecommendations(
        for player: Player,
        skillGaps: [String],
        trainingHistory: TrainingHistory,
        usedExercises: inout Set<String>
    ) -> [DrillRecommendation] {
        var recommendations: [DrillRecommendation] = []

        let exercises = fetchExercises(for: player)

        for gap in skillGaps.prefix(3) { // Focus on top 3 gaps
            // Find exercises for this skill that haven't been used yet
            // NEW: Also exclude exercises done in last 3 days
            let availableExercises = exercises.filter { exercise in
                let exerciseName = exercise.name ?? ""
                let notUsedYet = !usedExercises.contains(exerciseName)
                let notRecentlyCompleted = !trainingHistory.recentExercises.contains(exerciseName)
                return exercise.targetSkills?.contains(gap) == true &&
                       notUsedYet &&
                       notRecentlyCompleted
            }
            
            if let bestExercise = availableExercises.first {
                let exerciseName = bestExercise.name ?? ""
                usedExercises.insert(exerciseName)
                
                let reason = generateSkillGapDescription(for: player, skill: gap, trainingHistory: trainingHistory)
                let gapFrequency = trainingHistory.skillFrequency[gap] ?? 0
                let totalSessions = trainingHistory.totalSessions
                
                // Calculate more dynamic confidence based on actual data
                var confidence: Double = 0.5 // Base confidence

                // NEW: PRIORITY BOOST for recent poor performance (last 14 days)
                let recentPerformance = trainingHistory.recentSkillPerformance[gap]
                let veryRecentPerformance = trainingHistory.veryRecentSkillPerformance[gap]

                if let recentPerf = recentPerformance, recentPerf < 3.0 {
                    // Strong boost for recent poor performance
                    confidence = 0.82 + ((3.0 - recentPerf) * 0.04) // 82-90% for recent struggles
                    #if DEBUG
                    print("üî• PRIORITY: \(gap) performed poorly recently (\(String(format: "%.1f", recentPerf))/5) - boosting confidence to \(String(format: "%.0f%%", confidence * 100))")
                    #endif
                } else if let veryRecentPerf = veryRecentPerformance, veryRecentPerf < 3.5 {
                    // Moderate boost for very recent struggles
                    confidence = 0.75 + ((3.5 - veryRecentPerf) * 0.06) // 75-84% for last week struggles
                    #if DEBUG
                    print("‚ö° RECENT: \(gap) showed room to grow last week (\(String(format: "%.1f", veryRecentPerf))/5) - confidence: \(String(format: "%.0f%%", confidence * 100))")
                    #endif
                } else if gapFrequency == 0 && totalSessions > 5 {
                    // High confidence for completely neglected skills
                    confidence = 0.85
                } else if totalSessions == 0 {
                    // New players: base confidence on position and experience
                    confidence = 0.70
                } else if gapFrequency < totalSessions / 4 {
                    // Calculate variation based on how neglected the skill is
                    let neglectSeverity = Double(totalSessions / 4 - gapFrequency) / Double(totalSessions / 4)
                    confidence = 0.65 + (neglectSeverity * 0.10) // 65-75% based on neglect
                } else {
                    // Base confidence on actual skill performance if available
                    let skillPerf = trainingHistory.skillPerformance[gap] ?? 3.0
                    let performanceBonus = (3.0 - skillPerf) * 0.05 // More confidence for worse performance
                    confidence = 0.55 + performanceBonus // 55-65% range
                }

                // Boost confidence if player generally performs well in similar exercises
                if let skillPerf = trainingHistory.skillPerformance[gap], skillPerf > 3.5 {
                    confidence += 0.05
                }

                // Adjust for exercise difficulty vs player level
                let playerLevel = mapExperienceToLevel(player.experienceLevel ?? "Intermediate")
                let exerciseLevel = Int(bestExercise.difficulty)
                let levelDiff = abs(playerLevel - exerciseLevel)
                if levelDiff == 0 {
                    confidence += 0.08 // Perfect match
                } else if levelDiff == 1 {
                    confidence += 0.03 // Good match
                } else if levelDiff > 2 {
                    confidence -= 0.10 // Too far from player level
                }

                confidence = min(0.90, max(0.40, confidence)) // Clamp between 40-90%
                
                let physicalIndicators = analyzePhysicalIndicators(for: bestExercise)
                recommendations.append(DrillRecommendation(
                    exercise: bestExercise,
                    reason: reason,
                    priority: 1,
                    category: .skillGap,
                    confidenceScore: confidence,
                    physicalIndicators: physicalIndicators
                ))
            }
        }
        
        return recommendations
    }
    
    private func generateDifficultyProgressionRecommendations(
        for player: Player,
        currentLevel: Double,
        performancePattern: [Int: Double],
        trainingHistory: TrainingHistory,
        usedExercises: inout Set<String>
    ) -> [DrillRecommendation] {
        var recommendations: [DrillRecommendation] = []
        let exercises = fetchExercises(for: player)
        
        // If performing well, suggest next difficulty level
        let currentPerformance = performancePattern[Int(currentLevel)] ?? 0
        if currentPerformance >= 4.0 && currentLevel < 5.0 {
            let nextLevel = min(5, Int(currentLevel) + 1)
            
            let availableExercises = exercises.filter { exercise in
                let exerciseName = exercise.name ?? ""
                return Int(exercise.difficulty) == nextLevel && !usedExercises.contains(exerciseName)
            }
            
            if let progressionExercise = availableExercises.first {
                let exerciseName = progressionExercise.name ?? ""
                usedExercises.insert(exerciseName)
                
                let physicalIndicators = analyzePhysicalIndicators(for: progressionExercise)
                // Calculate confidence based on performance consistency
                var confidence = 0.65 + (currentPerformance - 4.0) * 0.15 // Base from performance
                
                // Add variation based on recent session count
                let recentSessionBonus = min(0.10, Double(trainingHistory.recentSessions.count) * 0.02)
                confidence += recentSessionBonus
                
                // Add deterministic variation based on training consistency
                let sessionConsistency = min(1.0, Double(trainingHistory.recentSessions.count) / 10.0)
                let consistencyBonus = sessionConsistency * 0.05 // Up to 5% bonus for consistent training
                confidence += consistencyBonus
                confidence = min(0.89, max(0.58, confidence)) // 58-89% range
                
                recommendations.append(DrillRecommendation(
                    exercise: progressionExercise,
                    reason: generateProgressionDescription(for: player, currentLevel: currentLevel, performance: currentPerformance, trainingHistory: trainingHistory),
                    priority: 2,
                    category: .difficultyProgression,
                    confidenceScore: confidence,
                    physicalIndicators: physicalIndicators
                ))
            }
        }
        
        // If struggling, suggest easier drills to build foundation
        if currentPerformance < 3.0 && currentLevel > 1.0 {
            let easierLevel = max(1, Int(currentLevel) - 1)
            
            let availableFoundationExercises = exercises.filter { exercise in
                let exerciseName = exercise.name ?? ""
                return Int(exercise.difficulty) == easierLevel && !usedExercises.contains(exerciseName)
            }
            
            if let foundationExercise = availableFoundationExercises.first {
                let exerciseName = foundationExercise.name ?? ""
                usedExercises.insert(exerciseName)
                
                let physicalIndicators = analyzePhysicalIndicators(for: foundationExercise)
                // Higher confidence for foundation building when struggling
                let strugglingIntensity = 5.0 - currentPerformance // How much they're struggling
                var confidence = 0.75 + (strugglingIntensity * 0.08) // Higher confidence when more struggling
                
                // Boost if they've been consistent in training
                if trainingHistory.totalSessions > 8 {
                    confidence += 0.06
                }
                
                // Add deterministic bonus based on experience level
                let experienceLevel = player.experienceLevel?.lowercased() ?? "intermediate"
                let experienceBonus = experienceLevel == "beginner" ? 0.04 : 0.02
                confidence += experienceBonus
                confidence = min(0.94, max(0.72, confidence)) // 72-94% range
                
                recommendations.append(DrillRecommendation(
                    exercise: foundationExercise,
                    reason: generateFoundationDescription(for: player, currentLevel: currentLevel, easierLevel: easierLevel, trainingHistory: trainingHistory),
                    priority: 1,
                    category: .difficultyProgression,
                    confidenceScore: confidence,
                    physicalIndicators: physicalIndicators
                ))
            }
        }
        
        return recommendations
    }
    
    private func generateVarietyRecommendations(
        for player: Player,
        trainingHistory: TrainingHistory,
        usedExercises: inout Set<String>
    ) -> [DrillRecommendation] {
        var recommendations: [DrillRecommendation] = []
        let exercises = fetchExercises(for: player)
        
        let allCategories = ["Technical", "Physical", "Tactical"]
        let underrepresentedCategories = allCategories.filter { category in
            (trainingHistory.categoryFrequency[category] ?? 0) < 2
        }
        
        for category in underrepresentedCategories.prefix(1) {
            let availableVarietyExercises = exercises.filter { exercise in
                let exerciseName = exercise.name ?? ""
                return exercise.category == category && !usedExercises.contains(exerciseName)
            }
            
            if let varietyExercise = availableVarietyExercises.first {
                let exerciseName = varietyExercise.name ?? ""
                usedExercises.insert(exerciseName)
                
                let physicalIndicators = analyzePhysicalIndicators(for: varietyExercise)
                // Calculate confidence based on how much variety is needed
                let categoryFreq = trainingHistory.categoryFrequency[category] ?? 0
                let totalSessions = trainingHistory.totalSessions
                let varietyNeed = max(0.0, 1.0 - Double(categoryFreq) / max(1.0, Double(totalSessions) / 3.0))
                
                var confidence = 0.45 + (varietyNeed * 0.25) // Base confidence increases with variety need
                
                // Lower confidence for variety recommendations (they're less critical)
                // Adjust based on how imbalanced the training is
                let totalCategorySessions = trainingHistory.categoryFrequency.values.reduce(0, +)
                let imbalanceLevel = totalCategorySessions > 0 ? 1.0 - (Double(categoryFreq) / Double(totalCategorySessions) * 3.0) : 0.5
                let imbalanceBonus = max(0.0, min(0.08, imbalanceLevel * 0.08))
                confidence += imbalanceBonus
                confidence = min(0.72, max(0.38, confidence)) // 38-72% range
                
                recommendations.append(DrillRecommendation(
                    exercise: varietyExercise,
                    reason: generateVarietyDescription(for: player, category: category, trainingHistory: trainingHistory),
                    priority: 3,
                    category: .varietyBalance,
                    confidenceScore: confidence,
                    physicalIndicators: physicalIndicators
                ))
            }
        }
        
        return recommendations
    }
    
    private func generateSuccessPatternRecommendations(
        for player: Player,
        trainingHistory: TrainingHistory,
        usedExercises: inout Set<String>
    ) -> [DrillRecommendation] {
        var recommendations: [DrillRecommendation] = []
        let exercises = fetchExercises(for: player)
        
        // Find skills where player performs well
        let strongSkills = trainingHistory.skillPerformance.filter { $0.value >= 4.0 }.keys
        
        for strongSkill in strongSkills.prefix(1) {
            let availableSuccessExercises = exercises.filter { exercise in
                let exerciseName = exercise.name ?? ""
                return exercise.targetSkills?.contains(strongSkill) == true &&
                       !usedExercises.contains(exerciseName) &&
                       !trainingHistory.recentSessions.contains { session in
                           session.exercises?.contains { sessionEx in
                               (sessionEx as? SessionExercise)?.exercise == exercise
                           } ?? false
                       }
            }
            
            if let similarExercise = availableSuccessExercises.first {
                let exerciseName = similarExercise.name ?? ""
                usedExercises.insert(exerciseName)
                
                let physicalIndicators = analyzePhysicalIndicators(for: similarExercise)
                // Calculate confidence based on how strong the skill performance is
                let performanceStrength = trainingHistory.skillPerformance[strongSkill] ?? 3.0
                var confidence = 0.45 + ((performanceStrength - 3.0) * 0.15) // Higher confidence for stronger skills
                
                // Boost confidence if they've done this skill recently
                let skillFreq = trainingHistory.skillFrequency[strongSkill] ?? 0
                if skillFreq > trainingHistory.totalSessions / 6 { // If practiced recently
                    confidence += 0.08
                }
                
                // Add deterministic bonus based on skill improvement trend
                let frequencyBonus = min(0.05, Double(skillFreq) / Double(max(1, trainingHistory.totalSessions)) * 0.2)
                confidence += frequencyBonus
                confidence = min(0.81, max(0.42, confidence)) // 42-81% range
                
                recommendations.append(DrillRecommendation(
                    exercise: similarExercise,
                    reason: generateSuccessDescription(for: player, strongSkill: strongSkill, skillPerformance: performanceStrength, trainingHistory: trainingHistory),
                    priority: 4,
                    category: .repeatSuccess,
                    confidenceScore: confidence,
                    physicalIndicators: physicalIndicators
                ))
            }
        }
        
        return recommendations
    }
    
    private func fetchAllExercises() -> [Exercise] {
        let request: NSFetchRequest<Exercise> = Exercise.fetchRequest()
        
        do {
            return try context.fetch(request)
        } catch {
            #if DEBUG
            print("‚ùå Failed to fetch exercises: \(error)")
            #endif
            return []
        }
    }
    
    func removeDuplicateExercises(for player: Player) {
        #if DEBUG
        print("üßπ Starting comprehensive duplicate cleanup for player \(player.name ?? "Unknown")...")
        #endif
        let exercises = fetchExercises(for: player)
        var nameToExercises: [String: [Exercise]] = [:]
        var videoIdToExercises: [String: [Exercise]] = [:]
        
        // Group exercises by normalized name and video ID
        for exercise in exercises {
            let name = normalizeExerciseName(exercise.name ?? "")
            nameToExercises[name, default: []].append(exercise)
            
            // Also group by YouTube video ID if present
            if let description = exercise.exerciseDescription,
               let videoId = extractVideoId(from: description) {
                videoIdToExercises[videoId, default: []].append(exercise)
            }
        }
        
        var duplicatesRemoved = 0
        var processedExercises: Set<NSManagedObjectID> = []
        
        // Remove duplicates by name
        for (name, exerciseGroup) in nameToExercises {
            if exerciseGroup.count > 1 {
                #if DEBUG
                print("üîç Found \(exerciseGroup.count) name duplicates for '\(name)'")
                
                #endif
                // Keep the first one that hasn't been processed, delete the rest
                var kept = false
                for exercise in exerciseGroup {
                    if !kept && !processedExercises.contains(exercise.objectID) {
                        processedExercises.insert(exercise.objectID)
                        kept = true
                        #if DEBUG
                        print("‚úÖ Keeping: \(exercise.name ?? "Unnamed")")
                        #endif
                    } else {
                        #if DEBUG
                        print("üóëÔ∏è Deleting: \(exercise.name ?? "Unnamed")")
                        #endif
                        context.delete(exercise)
                        duplicatesRemoved += 1
                    }
                }
            } else if let exercise = exerciseGroup.first {
                processedExercises.insert(exercise.objectID)
            }
        }
        
        // Remove duplicates by YouTube video ID
        for (videoId, exerciseGroup) in videoIdToExercises {
            if exerciseGroup.count > 1 {
                #if DEBUG
                print("üé• Found \(exerciseGroup.count) video ID duplicates for: \(videoId)")
                
                #endif
                // Keep the first one that hasn't been deleted, delete the rest
                let remainingExercises = exerciseGroup.filter { !$0.isDeleted }
                if remainingExercises.count > 1 {
                    for duplicateExercise in remainingExercises.dropFirst() {
                        #if DEBUG
                        print("üóëÔ∏è Deleting YouTube duplicate: \(duplicateExercise.name ?? "Unnamed")")
                        #endif
                        context.delete(duplicateExercise)
                        duplicatesRemoved += 1
                    }
                }
            }
        }
        
        if duplicatesRemoved > 0 {
            save()
            #if DEBUG
            print("üéâ Successfully removed \(duplicatesRemoved) duplicate exercises")
            #endif
        } else {
            #if DEBUG
            print("‚úÖ No duplicate exercises found")
            #endif
        }
        
        // Print final count
        let finalCount = fetchAllExercises().count
        #if DEBUG
        print("üìä Exercise library now contains \(finalCount) unique exercises")
        #endif
    }
    
    private func normalizeExerciseName(_ name: String) -> String {
        // Normalize name for better duplicate detection
        return name
            .lowercased()
            .replacingOccurrences(of: "&amp;", with: "&")
            .replacingOccurrences(of: "...", with: "")
            .trimmingCharacters(in: .whitespacesAndNewlines)
    }
    
    private func extractVideoId(from description: String) -> String? {
        // Extract YouTube video ID from description
        if let range = description.range(of: "Video ID: ") {
            let startIndex = range.upperBound
            let remainingString = String(description[startIndex...])
            if let endIndex = remainingString.firstIndex(of: "\n") ?? remainingString.firstIndex(of: " ") {
                return String(remainingString[..<endIndex])
            } else {
                return remainingString
            }
        }
        return nil
    }
    
    private func analyzePhysicalIndicators(for exercise: Exercise) -> PhysicalIndicators {
        let exerciseName = exercise.name?.lowercased() ?? ""
        let category = exercise.category ?? ""
        let difficulty = Int(exercise.difficulty)
        let skills = exercise.targetSkills ?? []
        
        // Analyze intensity based on exercise characteristics
        let intensity = determineIntensity(
            name: exerciseName,
            category: category,
            difficulty: difficulty,
            skills: skills
        )
        
        // Determine duration based on exercise type and difficulty
        let duration = determineDuration(
            name: exerciseName,
            category: category,
            difficulty: difficulty
        )
        
        // Identify physical demands
        let physicalDemands = identifyPhysicalDemands(
            name: exerciseName,
            category: category,
            skills: skills
        )
        
        // Calculate heart rate zone based on intensity and demands
        let heartRateZone = determineHeartRateZone(
            intensity: intensity,
            physicalDemands: physicalDemands
        )
        
        // Estimate recovery time
        let recoveryTime = determineRecoveryTime(
            intensity: intensity,
            duration: duration,
            physicalDemands: physicalDemands
        )
        
        return PhysicalIndicators(
            intensity: intensity,
            duration: duration,
            physicalDemands: physicalDemands,
            heartRateZone: heartRateZone,
            recoveryTime: recoveryTime
        )
    }
    
    private func determineIntensity(name: String, category: String, difficulty: Int, skills: [String]) -> PhysicalIntensity {
        var intensityScore = difficulty // Base on difficulty (1-5)
        
        // High-intensity keywords
        let highIntensityKeywords = ["sprint", "explosive", "plyometric", "interval", "agility ladder", "shuttle run"]
        let lowIntensityKeywords = ["juggling", "stationary", "walking", "flexibility"]
        
        if highIntensityKeywords.contains(where: name.contains) {
            intensityScore += 1
        } else if lowIntensityKeywords.contains(where: name.contains) {
            intensityScore -= 1
        }
        
        // Category-based adjustments
        switch category {
        case "Physical":
            intensityScore += 1
        case "Technical":
            intensityScore += 0
        case "Tactical":
            intensityScore += 0
        default:
            break
        }
        
        // Skill-based adjustments
        if skills.contains("Speed") || skills.contains("Agility") {
            intensityScore += 1
        }
        if skills.contains("Endurance") {
            intensityScore += 0 // Endurance can be moderate to high
        }
        
        // Clamp to valid range
        let clampedScore = max(1, min(5, intensityScore))
        return PhysicalIntensity(rawValue: clampedScore) ?? .moderate
    }
    
    private func determineDuration(name: String, category: String, difficulty: Int) -> PhysicalDuration {
        // Duration keywords
        let shortKeywords = ["sprint", "explosive", "plyometric", "juggling"]
        let longKeywords = ["endurance", "run", "continuous", "session"]
        
        if shortKeywords.contains(where: name.contains) {
            return .short
        } else if longKeywords.contains(where: name.contains) {
            return difficulty >= 4 ? .long : .medium
        }
        
        // Category-based defaults
        switch category {
        case "Physical":
            return difficulty >= 3 ? .medium : .short
        case "Technical":
            return .medium
        case "Tactical":
            return .long
        default:
            return .medium
        }
    }
    
    private func identifyPhysicalDemands(name: String, category: String, skills: [String]) -> [PhysicalDemand] {
        var demands: Set<PhysicalDemand> = []
        
        // Name-based analysis
        let nameAnalysis: [String: PhysicalDemand] = [
            "sprint": .speed,
            "run": .cardio,
            "endurance": .endurance,
            "agility": .agility,
            "strength": .strength,
            "power": .power,
            "balance": .balance,
            "coordination": .coordination,
            "flexibility": .flexibility,
            "reaction": .reaction,
            "juggling": .coordination,
            "dribbling": .agility,
            "shooting": .power,
            "passing": .coordination
        ]
        
        for (keyword, demand) in nameAnalysis {
            if name.contains(keyword) {
                demands.insert(demand)
            }
        }
        
        // Skill-based analysis
        let skillMapping: [String: PhysicalDemand] = [
            "Speed": .speed,
            "Agility": .agility,
            "Endurance": .endurance,
            "Ball Control": .coordination,
            "Coordination": .coordination,
            "Shooting": .power,
            "Dribbling": .agility
        ]
        
        for skill in skills {
            if let demand = skillMapping[skill] {
                demands.insert(demand)
            }
        }
        
        // Category-based defaults
        switch category {
        case "Physical":
            demands.insert(.cardio)
            demands.insert(.strength)
        case "Technical":
            demands.insert(.coordination)
            demands.insert(.balance)
        case "Tactical":
            demands.insert(.reaction)
            demands.insert(.cardio)
        default:
            demands.insert(.coordination)
        }
        
        return Array(demands).sorted { $0.rawValue < $1.rawValue }
    }
    
    private func determineHeartRateZone(intensity: PhysicalIntensity, physicalDemands: [PhysicalDemand]) -> HeartRateZone {
        var zoneScore = intensity.rawValue
        
        // Adjust based on physical demands
        if physicalDemands.contains(.speed) || physicalDemands.contains(.power) {
            zoneScore += 1
        }
        if physicalDemands.contains(.endurance) {
            zoneScore += 0 // Endurance can be various zones
        }
        if physicalDemands.contains(.cardio) {
            zoneScore += 1
        }
        
        let clampedZone = max(1, min(5, zoneScore))
        return HeartRateZone(rawValue: clampedZone) ?? .aerobic
    }
    
    private func determineRecoveryTime(intensity: PhysicalIntensity, duration: PhysicalDuration, physicalDemands: [PhysicalDemand]) -> RecoveryTime {
        var recoveryScore = intensity.rawValue
        
        // Duration impact
        switch duration {
        case .short:
            recoveryScore += 0
        case .medium:
            recoveryScore += 1
        case .long:
            recoveryScore += 2
        case .extended:
            recoveryScore += 3
        }
        
        // High-impact demands increase recovery
        let highImpactDemands: [PhysicalDemand] = [.speed, .power, .strength]
        let highImpactCount = physicalDemands.filter { highImpactDemands.contains($0) }.count
        recoveryScore += highImpactCount
        
        // Convert to recovery time
        switch recoveryScore {
        case 1...3:
            return .minimal
        case 4...5:
            return .short
        case 6...7:
            return .moderate
        case 8...9:
            return .long
        default:
            return .extended
        }
    }

    // MARK: - Drill Feedback

    func saveDrillFeedback(
        for exercise: Exercise,
        player: Player,
        rating: Int,
        difficultyFeedback: String,
        notes: String
    ) {
        let feedback = RecommendationFeedback(context: context)
        feedback.id = UUID()
        feedback.createdAt = Date()
        feedback.exerciseID = exercise.id?.uuidString
        feedback.rating = Int16(rating)
        feedback.recommendationSource = "AI-Generated"
        feedback.feedbackType = rating >= 4 ? "Positive" : rating <= 2 ? "Negative" : "Neutral"
        feedback.notes = notes.isEmpty ? nil : notes
        feedback.player = player

        // Map difficulty feedback to rating
        switch difficultyFeedback {
        case "easy":
            feedback.difficultyRating = 1
        case "right":
            feedback.difficultyRating = 3
        case "hard":
            feedback.difficultyRating = 5
        default:
            feedback.difficultyRating = 3
        }

        save()
        #if DEBUG
        print("‚úÖ Saved drill feedback: rating=\(rating), difficulty=\(difficultyFeedback)")
        #endif
    }

    func fetchDrillFeedback(for player: Player, limit: Int = 10) -> [RecommendationFeedback] {
        let request: NSFetchRequest<RecommendationFeedback> = RecommendationFeedback.fetchRequest()
        request.predicate = NSPredicate(format: "player == %@ AND recommendationSource == %@", player, "AI-Generated")
        request.sortDescriptors = [NSSortDescriptor(keyPath: \RecommendationFeedback.createdAt, ascending: false)]
        request.fetchLimit = limit

        do {
            return try context.fetch(request)
        } catch {
            #if DEBUG
            print("‚ùå Failed to fetch drill feedback: \(error)")
            #endif
            return []
        }
    }

    func fetchFeedback(for exercise: Exercise, player: Player) -> RecommendationFeedback? {
        guard let exerciseID = exercise.id?.uuidString else { return nil }

        let request: NSFetchRequest<RecommendationFeedback> = RecommendationFeedback.fetchRequest()
        request.predicate = NSPredicate(
            format: "player == %@ AND exerciseID == %@ AND recommendationSource == %@",
            player, exerciseID, "AI-Generated"
        )
        request.fetchLimit = 1

        return try? context.fetch(request).first
    }

    func getCompletionCount(for exercise: Exercise) -> Int {
        return exercise.sessionExercises?.count ?? 0
    }

    func getAveragePerformanceRating(for exercise: Exercise) -> Double {
        guard let sessionExercises = exercise.sessionExercises?.allObjects as? [SessionExercise],
              !sessionExercises.isEmpty else {
            return 0
        }

        let totalRating = sessionExercises.reduce(0) { $0 + Int($1.performanceRating) }
        return Double(totalRating) / Double(sessionExercises.count)
    }
}
