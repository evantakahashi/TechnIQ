import CoreData
import Foundation

enum TimeoutError: Error {
    case timeout
}

enum APIError: Error {
    case apiKeyNotConfigured
    case networkError
}

struct EnhancedVideoDetails {
    let description: String
    let duration: Int
    let viewCount: Int
    let publishedAt: String
}

struct VideoTranscript {
    let text: String
    let language: String
    let autoGenerated: Bool
}

struct EnhancedYouTubeVideo {
    let videoId: String
    let title: String
    let channel: String
    let description: String
    let duration: Int
    let transcript: VideoTranscript?
    let difficultyAnalysis: DifficultyAnalysis
}

struct DifficultyAnalysis {
    let difficulty: Int
    let confidence: Double
    let targetAudience: String
    let keySkills: [String]
    let reasoning: [String]
}

struct YouTubeVideo {
    let videoId: String
    let title: String
    let channel: String
    let duration: String
}

class CoreDataManager: ObservableObject {
    static let shared = CoreDataManager()
    
    // Circuit breaker state for API protection
    private var consecutiveFailures = 0
    private let maxConsecutiveFailures = 3
    
    // Simple in-memory cache for video details
    private var videoDetailsCache: [String: EnhancedVideoDetails] = [:]
    private var transcriptCache: [String: VideoTranscript] = [:]
    private let cacheExpirationTime: TimeInterval = 30 * 60  // 30 minutes
    
    lazy var persistentContainer: NSPersistentContainer = {
        let container = NSPersistentContainer(name: "DataModel")
        container.loadPersistentStores { _, error in
            if let error = error {
                fatalError("Core Data error: \(error.localizedDescription)")
            }
        }
        container.viewContext.automaticallyMergesChangesFromParent = true
        return container
    }()
    
    var context: NSManagedObjectContext {
        return persistentContainer.viewContext
    }
    
    func save() {
        if context.hasChanges {
            do {
                try context.save()
            } catch {
                print("Save error: \(error.localizedDescription)")
            }
        }
    }
}

extension CoreDataManager {
    // MARK: - User-aware data fetching
    
    func getCurrentPlayer(for firebaseUID: String) -> Player? {
        let request: NSFetchRequest<Player> = Player.fetchRequest()
        request.predicate = NSPredicate(format: "firebaseUID == %@", firebaseUID)
        request.fetchLimit = 1
        
        do {
            return try context.fetch(request).first
        } catch {
            print("‚ùå Failed to fetch current player: \(error)")
            return nil
        }
    }
    
    func fetchTrainingSessions(for firebaseUID: String) -> [TrainingSession] {
        guard let player = getCurrentPlayer(for: firebaseUID) else {
            print("‚ö†Ô∏è No player found for Firebase UID: \(firebaseUID)")
            return []
        }
        
        let request: NSFetchRequest<TrainingSession> = TrainingSession.fetchRequest()
        request.predicate = NSPredicate(format: "player == %@", player)
        request.sortDescriptors = [NSSortDescriptor(keyPath: \TrainingSession.date, ascending: false)]
        
        do {
            let sessions = try context.fetch(request)
            print("üìä Found \(sessions.count) training sessions for user \(firebaseUID)")
            return sessions
        } catch {
            print("‚ùå Failed to fetch training sessions: \(error)")
            return []
        }
    }
    
    func fetchExercises(for firebaseUID: String) -> [Exercise] {
        guard let player = getCurrentPlayer(for: firebaseUID) else {
            print("‚ö†Ô∏è No player found for Firebase UID: \(firebaseUID)")
            return []
        }
        
        return fetchExercises(for: player)
    }
    
    func createDefaultExercises(for player: Player) {
        // Check if exercises already exist for this player to prevent duplicates
        let existingExercises = fetchExercises(for: player)
        if !existingExercises.isEmpty {
            print("üìö Exercises already exist for player \(player.name ?? "Unknown"), skipping default creation")
            return
        }
        
        let exercises = [
            ("Ball Control", "Technical", 1, "Basic ball touches and control", ["Ball Control", "First Touch"]),
            ("Juggling", "Technical", 2, "Keep the ball in the air using different body parts", ["Ball Control", "Coordination"]),
            ("Dribbling Cones", "Technical", 2, "Dribble through a series of cones", ["Dribbling", "Agility"]),
            ("Shooting Practice", "Technical", 3, "Practice shooting accuracy and power", ["Shooting", "Accuracy"]),
            ("Passing Accuracy", "Technical", 2, "Short and long passing practice", ["Passing", "Vision"]),
            ("Sprint Training", "Physical", 2, "Short distance sprint intervals", ["Speed", "Acceleration"]),
            ("Agility Ladder", "Physical", 2, "Footwork and agility drills", ["Agility", "Coordination"]),
            ("Endurance Run", "Physical", 1, "Continuous running for stamina", ["Endurance", "Fitness"]),
            ("1v1 Practice", "Tactical", 3, "One-on-one attacking and defending", ["Defending", "Attacking"]),
            ("Small-Sided Games", "Tactical", 3, "3v3 or 4v4 mini games", ["Teamwork", "Decision Making"])
        ]
        
        for (name, category, difficulty, description, skills) in exercises {
            // Check if exercise with this name already exists for this player
            if !exerciseExists(name: name, for: player) {
                let exercise = Exercise(context: context)
                exercise.id = UUID()
                exercise.name = name
                exercise.category = category
                exercise.difficulty = Int16(difficulty)
                exercise.exerciseDescription = description
                exercise.targetSkills = skills
                exercise.instructions = "Follow standard \(name.lowercased()) protocol"
                exercise.setValue(player, forKey: "player")
            }
        }
        
        save()
    }
    
    private func exerciseExists(name: String, for player: Player) -> Bool {
        let request: NSFetchRequest<Exercise> = Exercise.fetchRequest()
        request.predicate = NSPredicate(format: "name == %@ AND player == %@", name, player)
        
        do {
            let count = try context.count(for: request)
            return count > 0
        } catch {
            print("‚ùå Failed to check exercise existence: \(error)")
            return false
        }
    }
    
    func fetchExercises(for player: Player) -> [Exercise] {
        let request: NSFetchRequest<Exercise> = Exercise.fetchRequest()
        request.predicate = NSPredicate(format: "player == %@", player)
        request.sortDescriptors = [NSSortDescriptor(keyPath: \Exercise.name, ascending: true)]
        
        do {
            return try context.fetch(request)
        } catch {
            print("‚ùå Failed to fetch exercises for player: \(error)")
            return []
        }
    }
    
    // MARK: - YouTube Integration
    
    func createExerciseFromYouTubeVideo(
        for player: Player,
        videoId: String,
        title: String,
        description: String,
        thumbnailURL: String,
        duration: Int,
        channelTitle: String,
        category: String = "Technical",
        difficulty: Int = 2,
        targetSkills: [String] = []
    ) -> Exercise? {
        // Check if exercise with this title already exists for this player
        if exerciseExists(name: title, for: player) {
            print("üìö Exercise '\(title)' already exists for player \(player.name ?? "Unknown"), skipping creation")
            return fetchExerciseByName(title, for: player)
        }
        
        // Check if exercise with this YouTube video ID already exists for this player
        if youTubeExerciseExists(videoId: videoId, for: player) {
            print("üì∫ YouTube exercise with video ID '\(videoId)' already exists for player \(player.name ?? "Unknown"), skipping creation")
            return fetchExerciseByVideoId(videoId, for: player)
        }
        
        let exercise = Exercise(context: context)
        exercise.id = UUID()
        exercise.name = title
        exercise.category = category
        exercise.difficulty = Int16(difficulty)
        exercise.exerciseDescription = description
        exercise.instructions = "Watch this YouTube video to learn the technique, then practice in real life."
        exercise.targetSkills = targetSkills
        exercise.setValue(player, forKey: "player")
        
        // Store YouTube info in the description for now (until Core Data fields are available)
        exercise.exerciseDescription = "\(description)\n\nüé• YouTube Video\nChannel: \(channelTitle)\nVideo ID: \(videoId)"
        exercise.instructions = "1. Watch the YouTube video at: https://youtube.com/watch?v=\(videoId)\n2. Practice the technique shown\n3. Focus on the key points demonstrated"
        
        save()
        return exercise
    }
    
    private func youTubeExerciseExists(videoId: String, for player: Player) -> Bool {
        let request: NSFetchRequest<Exercise> = Exercise.fetchRequest()
        request.predicate = NSPredicate(format: "exerciseDescription CONTAINS %@ AND player == %@", "Video ID: \(videoId)", player)
        
        do {
            let count = try context.count(for: request)
            return count > 0
        } catch {
            print("‚ùå Failed to check YouTube exercise existence: \(error)")
            return false
        }
    }
    
    private func fetchExerciseByName(_ name: String, for player: Player) -> Exercise? {
        let request: NSFetchRequest<Exercise> = Exercise.fetchRequest()
        request.predicate = NSPredicate(format: "name == %@ AND player == %@", name, player)
        request.fetchLimit = 1
        
        do {
            return try context.fetch(request).first
        } catch {
            print("‚ùå Failed to fetch exercise by name: \(error)")
            return nil
        }
    }
    
    private func fetchExerciseByVideoId(_ videoId: String, for player: Player) -> Exercise? {
        let request: NSFetchRequest<Exercise> = Exercise.fetchRequest()
        request.predicate = NSPredicate(format: "exerciseDescription CONTAINS %@ AND player == %@", "Video ID: \(videoId)", player)
        request.fetchLimit = 1
        
        do {
            return try context.fetch(request).first
        } catch {
            print("‚ùå Failed to fetch exercise by video ID: \(error)")
            return nil
        }
    }
    
    func loadYouTubeDrillsFromAPI(
        for player: Player, 
        category: String? = nil, 
        maxResults: Int = 10, 
        progressCallback: (@Sendable @MainActor (Double, String) -> Void)? = nil
    ) async throws {
        print("üöÄ Starting YouTube drill analysis with enhanced difficulty detection")
        print("üìã Category: \(category ?? "All"), Max Results: \(maxResults)")
        
        // Use the same method as YouTubeConfig for consistency
        guard let path = Bundle.main.path(forResource: "Info", ofType: "plist"),
              let plist = NSDictionary(contentsOfFile: path),
              let apiKey = plist["YOUTUBE_API_KEY"] as? String,
              !apiKey.isEmpty,
              apiKey != "YOUR_YOUTUBE_API_KEY_HERE" else {
            print("‚ö†Ô∏è YouTube API key not found or not configured in Info.plist")
            await progressCallback?(0.0, "API key not configured")
            throw APIError.apiKeyNotConfigured
        }
        
        Task { [self] in
            do {
                await progressCallback?(0.1, "Searching YouTube...")
                
                let searchQuery = category ?? "soccer training drills"
                print("üîç Performing enhanced YouTube search for: \(searchQuery)")
                print("üìù Note: Transcript analysis will be attempted but may not be available for all videos due to privacy restrictions")
                
                // Use enhanced search with transcript analysis, fallback to basic search if needed
                let enhancedVideos: [EnhancedYouTubeVideo]
                
                do {
                    await progressCallback?(0.2, "Analyzing videos...")
                    enhancedVideos = try await performEnhancedYouTubeSearch(
                        query: searchQuery, 
                        apiKey: apiKey, 
                        maxResults: maxResults
                    )
                } catch {
                    print("‚ö†Ô∏è Enhanced search failed, falling back to basic search: \(error)")
                    await progressCallback?(0.3, "Using basic search...")
                    
                    // Fallback to basic search without enhanced analysis
                    let basicVideos = try await self.performYouTubeSearch(query: searchQuery, apiKey: apiKey, maxResults: maxResults)
                    enhancedVideos = basicVideos.map { video in
                        let basicAnalysis = analyzeVideoDifficultyComprehensive(
                            title: video.title,
                            description: "",
                            transcript: nil,
                            duration: 300, // Default duration
                            channelTitle: video.channel
                        )
                        return EnhancedYouTubeVideo(
                            videoId: video.videoId,
                            title: video.title,
                            channel: video.channel,
                            description: video.title, // Use title as description fallback
                            duration: 300,
                            transcript: nil,
                            difficultyAnalysis: basicAnalysis
                        )
                    }
                }
                
                await progressCallback?(0.6, "Creating exercises...")
                
                let totalVideos = enhancedVideos.count
                for (index, video) in enhancedVideos.enumerated() {
                    // Update progress for each video
                    let videoProgress = 0.6 + (0.3 * Double(index) / Double(totalVideos))
                    await progressCallback?(videoProgress, "Processing video \(index + 1) of \(totalVideos)")
                    
                    // Check if we already have this video
                    let existingExercise = findExerciseByYouTubeID(video.videoId, for: player)
                    if existingExercise == nil {
                        
                        print("üìä Video Analysis for '\(video.title.prefix(50))...':")
                        print("   Difficulty: \(video.difficultyAnalysis.difficulty)/5")
                        print("   Confidence: \(String(format: "%.1f", video.difficultyAnalysis.confidence * 100))%")
                        print("   Target: \(video.difficultyAnalysis.targetAudience)")
                        print("   Skills: \(video.difficultyAnalysis.keySkills.joined(separator: ", "))")
                        print("   Transcript: \(video.transcript != nil ? "‚úÖ Available" : "‚ùå Not available")")
                        if !video.difficultyAnalysis.reasoning.isEmpty {
                            print("   Reasoning: \(video.difficultyAnalysis.reasoning.prefix(3).joined(separator: "; "))")
                        }
                        
                        _ = createEnhancedExerciseFromYouTubeVideo(
                            for: player,
                            videoId: video.videoId,
                            title: video.title,
                            description: video.description,
                            thumbnailURL: "https://img.youtube.com/vi/\(video.videoId)/medium.jpg",
                            duration: video.duration,
                            channelTitle: video.channel,
                            category: category ?? "Technical",
                            difficultyAnalysis: video.difficultyAnalysis,
                            transcript: video.transcript
                        )
                    }
                }
                await progressCallback?(0.95, "Finalizing...")
            } catch {
                print("Error loading YouTube drills: \(error)")
                await progressCallback?(0.0, "Error occurred")
            }
        }
    }
    
    // Enhanced exercise creation with comprehensive analysis
    private func createEnhancedExerciseFromYouTubeVideo(
        for player: Player,
        videoId: String,
        title: String,
        description: String,
        thumbnailURL: String,
        duration: Int,
        channelTitle: String,
        category: String,
        difficultyAnalysis: DifficultyAnalysis,
        transcript: VideoTranscript?
    ) -> Exercise {
        let exercise = Exercise(context: context)
        exercise.id = UUID()
        exercise.name = title
        exercise.category = category
        exercise.difficulty = Int16(difficultyAnalysis.difficulty)
        exercise.exerciseDescription = description
        exercise.targetSkills = difficultyAnalysis.keySkills
        exercise.setValue(player, forKey: "player")
        // Set YouTube-specific fields if available
        exercise.setValue(true, forKey: "isYouTubeContent")
        exercise.setValue(videoId, forKey: "youtubeVideoID")
        exercise.setValue(thumbnailURL, forKey: "videoThumbnailURL")
        exercise.setValue(Int32(duration), forKey: "videoDuration")
        
        // Enhanced description with analysis insights
        var enhancedDescription = description
        if !enhancedDescription.isEmpty {
            enhancedDescription += "\n\n"
        }
        
        enhancedDescription += "üéØ Difficulty Analysis:\n"
        enhancedDescription += "‚Ä¢ Level: \(difficultyAnalysis.difficulty)/5 (\(difficultyAnalysis.targetAudience))\n"
        enhancedDescription += "‚Ä¢ Confidence: \(Int(difficultyAnalysis.confidence * 100))%\n"
        
        if !difficultyAnalysis.keySkills.isEmpty {
            enhancedDescription += "‚Ä¢ Skills: \(difficultyAnalysis.keySkills.joined(separator: ", "))\n"
        }
        
        if transcript != nil {
            enhancedDescription += "‚Ä¢ Full transcript available for detailed analysis\n"
        }
        
        if !difficultyAnalysis.reasoning.isEmpty {
            enhancedDescription += "‚Ä¢ Analysis: \(difficultyAnalysis.reasoning.joined(separator: "; "))\n"
        }
        
        enhancedDescription += "\nüé• YouTube Video\nChannel: \(channelTitle)\nDuration: \(formatDuration(duration))"
        
        exercise.exerciseDescription = enhancedDescription
        
        // Enhanced instructions based on difficulty level
        var instructions = "1. Watch the YouTube video at: https://youtube.com/watch?v=\(videoId)\n"
        
        switch difficultyAnalysis.difficulty {
        case 1:
            instructions += "2. This is a beginner drill - focus on proper form over speed\n"
            instructions += "3. Practice slowly and build confidence\n"
            instructions += "4. Master the basics before progressing"
        case 2:
            instructions += "2. This is an intermediate drill - ensure you have the fundamentals\n"
            instructions += "3. Focus on technique and consistency\n"
            instructions += "4. Gradually increase intensity as you improve"
        case 3:
            instructions += "2. This is an advanced drill - requires solid fundamentals\n"
            instructions += "3. Pay attention to timing and coordination\n"
            instructions += "4. Challenge yourself while maintaining quality"
        case 4:
            instructions += "2. This is an expert-level drill - master prerequisite skills first\n"
            instructions += "3. Focus on precision and game-like intensity\n"
            instructions += "4. Analyze your performance critically"
        default:
            instructions += "2. This is a professional-level drill - elite technique required\n"
            instructions += "3. Perfect execution under pressure is essential\n"
            instructions += "4. Seek coaching feedback for refinement"
        }
        
        exercise.instructions = instructions
        
        save()
        return exercise
    }
    
    private func formatDuration(_ seconds: Int) -> String {
        let minutes = seconds / 60
        let remainingSeconds = seconds % 60
        return String(format: "%d:%02d", minutes, remainingSeconds)
    }
    
    private func findExerciseByYouTubeID(_ videoId: String, for player: Player) -> Exercise? {
        let request: NSFetchRequest<Exercise> = Exercise.fetchRequest()
        // Check both the new youtubeVideoID field and legacy description format
        // Use value(forKey:) to safely check YouTube fields
        request.predicate = NSPredicate(format: "exerciseDescription CONTAINS %@ AND player == %@", "Video ID: \(videoId)", player)
        request.fetchLimit = 1
        
        do {
            let results = try context.fetch(request)
            return results.first
        } catch {
            print("Error finding exercise by YouTube ID: \(error)")
            return nil
        }
    }
    
    private func analyzeVideoForSkills(title: String, description: String) -> [String] {
        let content = (title + " " + description).lowercased()
        var skills: [String] = []
        
        if content.contains("dribbling") || content.contains("dribble") {
            skills.append("Dribbling")
        }
        if content.contains("passing") || content.contains("pass") {
            skills.append("Passing")
        }
        if content.contains("shooting") || content.contains("shot") {
            skills.append("Shooting")
        }
        if content.contains("control") || content.contains("touch") {
            skills.append("Ball Control")
        }
        if content.contains("speed") || content.contains("sprint") {
            skills.append("Speed")
        }
        if content.contains("agility") || content.contains("footwork") {
            skills.append("Agility")
        }
        
        return skills.isEmpty ? ["Ball Control"] : skills
    }
    
    private func analyzeVideoDifficulty(title: String) -> Int {
        let analysis = analyzeVideoDifficultyComprehensive(
            title: title,
            description: "",
            transcript: nil,
            duration: 0,
            channelTitle: ""
        )
        return analysis.difficulty
    }
    
    // MARK: - Enhanced Difficulty Analysis System
    
    // Using DifficultyAnalysis and VideoTranscript from YouTubeModels.swift
    
    private func analyzeVideoDifficultyComprehensive(
        title: String,
        description: String,
        transcript: String?,
        duration: Int,
        channelTitle: String
    ) -> DifficultyAnalysis {
        
        var totalScore: Double = 0
        var confidenceScore: Double = 0
        var reasoning: [String] = []
        var keySkills: [String] = []
        
        // Title Analysis (20% weight)
        let titleAnalysis = analyzeTitleDifficulty(title)
        totalScore += titleAnalysis.score * 0.2
        confidenceScore += titleAnalysis.confidence * 0.2
        reasoning.append(contentsOf: titleAnalysis.reasoning)
        keySkills.append(contentsOf: titleAnalysis.skills)
        
        // Description Analysis (30% weight)
        let descriptionAnalysis = analyzeDescriptionDifficulty(description)
        totalScore += descriptionAnalysis.score * 0.3
        confidenceScore += descriptionAnalysis.confidence * 0.3
        reasoning.append(contentsOf: descriptionAnalysis.reasoning)
        keySkills.append(contentsOf: descriptionAnalysis.skills)
        
        // Transcript Analysis (40% weight) - Most important
        if let transcript = transcript, !transcript.isEmpty {
            let transcriptAnalysis = analyzeTranscriptDifficulty(transcript)
            totalScore += transcriptAnalysis.score * 0.4
            confidenceScore += transcriptAnalysis.confidence * 0.4
            reasoning.append(contentsOf: transcriptAnalysis.reasoning)
            keySkills.append(contentsOf: transcriptAnalysis.skills)
        } else {
            // Reweight other factors if no transcript available
            totalScore = (titleAnalysis.score * 0.4) + (descriptionAnalysis.score * 0.6)
            confidenceScore = (titleAnalysis.confidence * 0.4) + (descriptionAnalysis.confidence * 0.6)
            reasoning.append("Transcript analysis unavailable - using title and description analysis")
        }
        
        // Metadata Analysis (10% weight)
        let metadataAnalysis = analyzeMetadataDifficulty(duration: duration, channelTitle: channelTitle)
        totalScore += metadataAnalysis.score * 0.1
        confidenceScore += metadataAnalysis.confidence * 0.1
        reasoning.append(contentsOf: metadataAnalysis.reasoning)
        
        // Convert score to 1-5 scale
        let difficulty = max(1, min(5, Int(round(totalScore))))
        
        // Determine target audience
        let targetAudience = determineTargetAudience(score: totalScore)
        
        return DifficultyAnalysis(
            difficulty: difficulty,
            confidence: min(1.0, confidenceScore),
            targetAudience: targetAudience,
            keySkills: Array(Set(keySkills)), // Remove duplicates
            reasoning: reasoning
        )
    }
    
    // MARK: - Individual Analysis Components
    
    private struct AnalysisResult {
        let score: Double // 1.0-5.0
        let confidence: Double // 0.0-1.0
        let reasoning: [String]
        let skills: [String]
    }
    
    private func analyzeTitleDifficulty(_ title: String) -> AnalysisResult {
        let content = title.lowercased()
        var score: Double = 2.5 // Default to intermediate
        var confidence: Double = 0.6
        var reasoning: [String] = []
        var skills: [String] = []
        
        // Beginner indicators
        let beginnerKeywords = ["beginner", "basic", "simple", "easy", "introduction", "learn", "first time", "start"]
        let beginnerCount = beginnerKeywords.filter { content.contains($0) }.count
        
        // Intermediate indicators
        let intermediateKeywords = ["intermediate", "improve", "develop", "practice", "training", "drill"]
        let intermediateCount = intermediateKeywords.filter { content.contains($0) }.count
        
        // Advanced indicators
        let advancedKeywords = ["advanced", "professional", "expert", "master", "complex", "high level", "elite"]
        let advancedCount = advancedKeywords.filter { content.contains($0) }.count
        
        // Calculate score based on keyword presence
        if advancedCount > 0 {
            score = 4.0 + min(1.0, Double(advancedCount) * 0.3)
            confidence = 0.8
            reasoning.append("Advanced terminology in title")
        } else if beginnerCount > 0 {
            score = 1.5 + min(1.0, Double(beginnerCount) * 0.3)
            confidence = 0.8
            reasoning.append("Beginner terminology in title")
        } else if intermediateCount > 0 {
            score = 2.5 + min(1.0, Double(intermediateCount) * 0.2)
            confidence = 0.7
            reasoning.append("Intermediate terminology in title")
        }
        
        // Extract skills from title
        let skillKeywords = [
            "dribbling": "Dribbling", "passing": "Passing", "shooting": "Shooting",
            "control": "Ball Control", "juggling": "Ball Control", "finishing": "Shooting",
            "crossing": "Passing", "defending": "Defending", "goalkeeping": "Goalkeeping"
        ]
        
        for (keyword, skill) in skillKeywords {
            if content.contains(keyword) {
                skills.append(skill)
            }
        }
        
        return AnalysisResult(score: score, confidence: confidence, reasoning: reasoning, skills: skills)
    }
    
    private func analyzeDescriptionDifficulty(_ description: String) -> AnalysisResult {
        let content = description.lowercased()
        var score: Double = 2.5
        var confidence: Double = 0.7
        var reasoning: [String] = []
        var skills: [String] = []
        
        // More comprehensive analysis for descriptions
        let beginnerPhrases = [
            "for beginners", "new to soccer", "just starting", "basic technique",
            "fundamental", "first learn", "simple drill"
        ]
        
        let intermediatePhrases = [
            "build on", "next level", "improve your", "combine", "coordination",
            "timing", "intermediate players", "develop"
        ]
        
        let advancedPhrases = [
            "advanced technique", "professional level", "master this", "complex movement",
            "high intensity", "elite training", "tactical awareness"
        ]
        
        let beginnerMatches = beginnerPhrases.filter { content.contains($0) }.count
        let intermediateMatches = intermediatePhrases.filter { content.contains($0) }.count
        let advancedMatches = advancedPhrases.filter { content.contains($0) }.count
        
        // Calculate weighted score
        if advancedMatches > 0 {
            score = 4.0 + min(1.0, Double(advancedMatches) * 0.25)
            confidence = 0.85
            reasoning.append("Advanced concepts in description")
        } else if beginnerMatches > 0 {
            score = 1.5 + min(1.5, Double(beginnerMatches) * 0.25)
            confidence = 0.85
            reasoning.append("Beginner-focused description")
        } else if intermediateMatches > 0 {
            score = 2.5 + min(1.0, Double(intermediateMatches) * 0.2)
            confidence = 0.8
            reasoning.append("Intermediate concepts in description")
        }
        
        // Extract prerequisite complexity
        if content.contains("make sure you can") || content.contains("first master") {
            score += 0.5
            reasoning.append("Prerequisites mentioned")
        }
        
        // Extract skills
        let skillPatterns = [
            ("dribbl", "Dribbling"), ("pass", "Passing"), ("shoot", "Shooting"),
            ("control", "Ball Control"), ("defend", "Defending"), ("cross", "Passing"),
            ("finish", "Shooting"), ("agility", "Agility"), ("speed", "Speed")
        ]
        
        for (pattern, skill) in skillPatterns {
            if content.contains(pattern) {
                skills.append(skill)
            }
        }
        
        return AnalysisResult(score: score, confidence: confidence, reasoning: reasoning, skills: skills)
    }
    
    private func analyzeTranscriptDifficulty(_ transcript: String) -> AnalysisResult {
        let content = transcript.lowercased()
        var score: Double = 2.5
        let confidence: Double = 0.9 // Highest confidence since it's actual content
        var reasoning: [String] = []
        var skills: [String] = []
        
        // Analyze instruction complexity
        let instructionWords = content.components(separatedBy: " ")
        let wordCount = instructionWords.count
        
        // Technical terminology frequency
        let technicalTerms = [
            "technique", "biomechanics", "tactical", "positioning", "acceleration",
            "deceleration", "coordination", "proprioception", "muscle memory"
        ]
        let technicalCount = technicalTerms.filter { content.contains($0) }.count
        
        // Instruction complexity indicators
        let complexInstructions = [
            "simultaneously", "while maintaining", "as you", "make sure to",
            "coordinate", "timing is crucial", "precise", "exactly when"
        ]
        let complexCount = complexInstructions.filter { content.contains($0) }.count
        
        // Beginner language patterns
        let beginnerPatterns = [
            "let's start with", "very simple", "don't worry about", "just focus on",
            "take your time", "slowly", "basic movement"
        ]
        let beginnerCount = beginnerPatterns.filter { content.contains($0) }.count
        
        // Advanced language patterns
        let advancedPatterns = [
            "advanced players", "professional level", "must master", "quick decision",
            "under pressure", "high tempo", "elite technique"
        ]
        let advancedCount = advancedPatterns.filter { content.contains($0) }.count
        
        // Calculate base score from word count and complexity
        if wordCount > 1000 {
            score += 0.5 // Longer explanations = more complex
            reasoning.append("Detailed instruction content")
        }
        
        if technicalCount > 3 {
            score += 1.0
            reasoning.append("High technical terminology usage")
        } else if technicalCount > 1 {
            score += 0.5
            reasoning.append("Moderate technical terminology")
        }
        
        if complexCount > 5 {
            score += 1.0
            reasoning.append("Complex multi-step instructions")
        } else if complexCount > 2 {
            score += 0.5
            reasoning.append("Moderate instruction complexity")
        }
        
        // Adjust for explicit difficulty indicators
        if advancedCount > 0 {
            score += 1.5
            reasoning.append("Advanced concepts in instruction")
        } else if beginnerCount > 0 {
            score -= 1.0
            reasoning.append("Beginner-friendly instruction style")
        }
        
        // Count of sequential steps mentioned
        let stepIndicators = ["step", "first", "second", "third", "then", "next", "finally"]
        let stepCount = stepIndicators.filter { content.contains($0) }.count
        if stepCount > 8 {
            score += 0.5
            reasoning.append("Multi-step drill sequence")
        }
        
        // Extract skills from detailed content
        let detailedSkillPatterns = [
            ("first touch", "Ball Control"), ("weak foot", "Ambidexterity"),
            ("spatial awareness", "Vision"), ("decision making", "Decision Making"),
            ("body positioning", "Positioning"), ("tempo", "Game Intelligence")
        ]
        
        for (pattern, skill) in detailedSkillPatterns {
            if content.contains(pattern) {
                skills.append(skill)
            }
        }
        
        // Ensure score stays within bounds
        score = max(1.0, min(5.0, score))
        
        return AnalysisResult(score: score, confidence: confidence, reasoning: reasoning, skills: skills)
    }
    
    private func analyzeMetadataDifficulty(duration: Int, channelTitle: String) -> AnalysisResult {
        var score: Double = 2.5
        var confidenceLevel: Double = 0.4 // Lower confidence for metadata
        var reasoning: [String] = []
        let skills: [String] = []
        
        // Duration analysis
        if duration > 900 { // 15+ minutes
            score += 0.5
            reasoning.append("Extended duration suggests complex content")
        } else if duration < 180 { // Less than 3 minutes
            score -= 0.3
            reasoning.append("Short duration suggests simple drill")
        }
        
        // Channel authority analysis
        let professionalChannels = [
            "uefa", "fifa", "academy", "professional", "coach", "training center",
            "football club", "soccer club", "premier league", "la liga"
        ]
        
        let channelLower = channelTitle.lowercased()
        let isProfessional = professionalChannels.contains { channelLower.contains($0) }
        
        if isProfessional {
            score += 0.3
            confidenceLevel += 0.2
            reasoning.append("Professional/Academy channel")
        }
        
        return AnalysisResult(score: score, confidence: confidenceLevel, reasoning: reasoning, skills: skills)
    }
    
    private func determineTargetAudience(score: Double) -> String {
        switch score {
        case 1.0..<2.0: return "beginner"
        case 2.0..<3.5: return "intermediate"
        case 3.5..<4.5: return "advanced"
        default: return "expert"
        }
    }
    
    // MARK: - YouTube Transcript Integration
    
    private func fetchVideoTranscript(videoId: String, apiKey: String) async -> VideoTranscript? {
        do {
            // First, get available caption tracks
            let captionTracks = try await fetchCaptionTracks(videoId: videoId, apiKey: apiKey)
            
            // Find English caption track (prefer auto-generated for better availability)
            guard let captionTrack = findBestCaptionTrack(tracks: captionTracks) else {
                print("üìù No suitable caption track found for video: \(videoId) (this is normal - most videos don't have public captions)")
                return nil
            }
            
            // Download the caption content
            let transcriptText = try await downloadCaptionContent(captionUrl: captionTrack.url)
            
            return VideoTranscript(
                text: transcriptText,
                language: captionTrack.language,
                autoGenerated: captionTrack.kind == "asr"
            )
            
        } catch {
            // Gracefully handle caption access errors - this is expected for most videos
            if let httpError = error as? SimpleAPIError {
                switch httpError {
                case .networkError:
                    print("üìù Captions not accessible for video \(videoId) (privacy/auth restrictions)")
                default:
                    print("üìù Caption fetch failed for video \(videoId): \(error.localizedDescription)")
                }
            } else {
                print("üìù Caption fetch failed for video \(videoId): \(error)")
            }
            return nil
        }
    }
    
    private struct CaptionTrack {
        let id: String
        let url: String
        let language: String
        let kind: String // "asr" for auto-generated, "" for manual
    }
    
    private func fetchCaptionTracks(videoId: String, apiKey: String) async throws -> [CaptionTrack] {
        let urlString = "https://www.googleapis.com/youtube/v3/captions?part=snippet&videoId=\(videoId)&key=\(apiKey)"
        
        guard let url = URL(string: urlString) else {
            throw SimpleAPIError.invalidSearchQuery
        }
        
        let (data, response) = try await URLSession.shared.data(from: url)
        
        guard let httpResponse = response as? HTTPURLResponse else {
            throw SimpleAPIError.networkError
        }
        
        guard 200...299 ~= httpResponse.statusCode else {
            // Handle specific HTTP error codes for captions API
            switch httpResponse.statusCode {
            case 403:
                print("‚ö†Ô∏è Captions API: Permission denied (403) - video \(videoId) may have restricted captions")
            case 404:
                print("‚ö†Ô∏è Captions API: Video \(videoId) not found (404)")
            default:
                print("‚ö†Ô∏è Captions API: HTTP error \(httpResponse.statusCode) for video \(videoId)")
            }
            throw SimpleAPIError.networkError
        }
        
        guard let json = try JSONSerialization.jsonObject(with: data) as? [String: Any],
              let items = json["items"] as? [[String: Any]] else {
            return []
        }
        
        return items.compactMap { item in
            guard let id = item["id"] as? String,
                  let snippet = item["snippet"] as? [String: Any],
                  let language = snippet["language"] as? String else {
                return nil
            }
            
            // YouTube provides download URL in the snippet for public captions
            let downloadUrl = "https://www.googleapis.com/youtube/v3/captions/\(id)?tfmt=srt&key=\(apiKey)"
            
            return CaptionTrack(
                id: id,
                url: downloadUrl,
                language: language,
                kind: snippet["trackKind"] as? String ?? ""
            )
        }
    }
    
    private func findBestCaptionTrack(tracks: [CaptionTrack]) -> CaptionTrack? {
        // Priority: English manual > English auto > any manual > any auto
        
        // First try English manual captions
        if let englishManual = tracks.first(where: { $0.language == "en" && $0.kind != "asr" }) {
            return englishManual
        }
        
        // Then try English auto-generated
        if let englishAuto = tracks.first(where: { $0.language == "en" && $0.kind == "asr" }) {
            return englishAuto
        }
        
        // Then try any manual captions
        if let anyManual = tracks.first(where: { $0.kind != "asr" }) {
            return anyManual
        }
        
        // Finally, any auto-generated
        return tracks.first
    }
    
    private func downloadCaptionContent(captionUrl: String) async throws -> String {
        guard let url = URL(string: captionUrl) else {
            throw SimpleAPIError.invalidSearchQuery
        }
        
        let (data, response) = try await URLSession.shared.data(from: url)
        
        guard let httpResponse = response as? HTTPURLResponse,
              200...299 ~= httpResponse.statusCode else {
            throw SimpleAPIError.networkError
        }
        
        guard let content = String(data: data, encoding: .utf8) else {
            throw SimpleAPIError.parsingError
        }
        
        // Parse SRT format to extract just the text
        return parseSRTContent(content)
    }
    
    private func parseSRTContent(_ srtContent: String) -> String {
        let lines = srtContent.components(separatedBy: .newlines)
        var textLines: [String] = []
        var isTextLine = false
        
        for line in lines {
            let trimmedLine = line.trimmingCharacters(in: .whitespacesAndNewlines)
            
            // Skip empty lines
            if trimmedLine.isEmpty {
                isTextLine = false
                continue
            }
            
            // Skip sequence numbers (just digits)
            if Int(trimmedLine) != nil {
                continue
            }
            
            // Skip timestamp lines (contain -->)
            if trimmedLine.contains("-->") {
                isTextLine = true
                continue
            }
            
            // This is actual caption text
            if isTextLine {
                // Clean up HTML tags and formatting
                let cleanText = trimmedLine
                    .replacingOccurrences(of: "<[^>]+>", with: "", options: .regularExpression)
                    .replacingOccurrences(of: "&amp;", with: "&")
                    .replacingOccurrences(of: "&lt;", with: "<")
                    .replacingOccurrences(of: "&gt;", with: ">")
                
                if !cleanText.isEmpty {
                    textLines.append(cleanText)
                }
            }
        }
        
        return textLines.joined(separator: " ")
    }
    
    // MARK: - Enhanced Video Search with Transcript Analysis
    
    private func performEnhancedYouTubeSearch(query: String, apiKey: String, maxResults: Int) async throws -> [EnhancedYouTubeVideo] {
        // Set up cache expiration for next time
        clearExpiredCache()
        
        // First get basic video info
        let basicVideos = try await performYouTubeSearch(query: query, apiKey: apiKey, maxResults: maxResults)
        
        print("üöÄ Processing \(basicVideos.count) videos concurrently for enhanced analysis...")
        
        // Process all videos concurrently using TaskGroup with enhanced error handling
        let enhancedVideos = try await withThrowingTaskGroup(of: EnhancedYouTubeVideo?.self) { group in
            // Add a task for each video
            for video in basicVideos {
                group.addTask {
                    do {
                        return await self.processVideoEnhanced(video: video, apiKey: apiKey)
                    } catch {
                        print("‚ö†Ô∏è TaskGroup error for video \(video.title.prefix(30)): \(error)")
                        return nil
                    }
                }
            }
            
            // Collect results as they complete with error resilience
            var results: [EnhancedYouTubeVideo] = []
            var completedCount = 0
            let totalCount = basicVideos.count
            
            do {
                for try await enhancedVideo in group {
                    completedCount += 1
                    print("üìä Progress: \(completedCount)/\(totalCount) videos processed")
                    
                    if let video = enhancedVideo {
                        results.append(video)
                    }
                }
            } catch {
                print("‚ö†Ô∏è TaskGroup collection error: \(error)")
                // Continue with whatever results we have
            }
            
            return results
        }
        
        print("‚úÖ Enhanced analysis complete for \(enhancedVideos.count) videos")
        return enhancedVideos
    }
    
    // MARK: - Timeout and Retry Utilities
    
    private func withRetry<T>(maxAttempts: Int, operation: @escaping () async throws -> T) async throws -> T {
        var lastError: Error?
        
        for attempt in 1...maxAttempts {
            do {
                return try await operation()
            } catch {
                lastError = error
                print("‚ö†Ô∏è Attempt \(attempt)/\(maxAttempts) failed: \(error)")
                
                if attempt < maxAttempts {
                    // Exponential backoff: wait 0.5s, then 1s
                    let backoffTime = 0.5 * pow(2.0, Double(attempt - 1))
                    try await Task.sleep(nanoseconds: UInt64(backoffTime * 1_000_000_000))
                }
            }
        }
        
        throw lastError ?? TimeoutError.timeout
    }
    
    private func withTimeout<T>(seconds: TimeInterval, operation: @escaping () async throws -> T) async throws -> T {
        try await withThrowingTaskGroup(of: T.self) { group in
            group.addTask {
                try await operation()
            }
            
            group.addTask {
                try await Task.sleep(nanoseconds: UInt64(seconds * 1_000_000_000))
                throw TimeoutError.timeout
            }
            
            guard let result = try await group.next() else {
                throw TimeoutError.timeout
            }
            
            group.cancelAll()
            return result
        }
    }
    
    private func withTimeout<T>(seconds: TimeInterval, operation: @escaping () async -> T) async -> T? {
        do {
            return try await withThrowingTaskGroup(of: T?.self) { group in
                group.addTask {
                    await operation()
                }
                
                group.addTask {
                    try await Task.sleep(nanoseconds: UInt64(seconds * 1_000_000_000))
                    return nil
                }
                
                guard let result = try await group.next() else {
                    return nil
                }
                
                group.cancelAll()
                return result
            }
        } catch {
            return nil
        }
    }
    
    // Helper method to process individual video with error handling
    private func processVideoEnhanced(video: YouTubeVideo, apiKey: String) async -> EnhancedYouTubeVideo? {
        // Circuit breaker: skip processing if too many consecutive failures
        if consecutiveFailures >= maxConsecutiveFailures {
            print("üö® Circuit breaker activated - skipping video processing due to \(consecutiveFailures) consecutive failures")
            return createFallbackVideo(video: video)
        }
        do {
            print("üîç Processing video: \(video.title.prefix(50))...")
            
            // Get video details with caching
            let videoDetails = try await getCachedVideoDetails(videoId: video.videoId, apiKey: apiKey)
            
            // Fetch transcript with caching
            let transcript = await getCachedTranscript(videoId: video.videoId, apiKey: apiKey)
            
            // Perform comprehensive difficulty analysis
            let difficultyAnalysis = analyzeVideoDifficultyComprehensive(
                title: video.title,
                description: videoDetails?.description ?? "",
                transcript: transcript?.text,
                duration: videoDetails?.duration ?? 300,
                channelTitle: video.channel
            )
            
            let enhancedVideo = EnhancedYouTubeVideo(
                videoId: video.videoId,
                title: video.title,
                channel: video.channel,
                description: videoDetails?.description ?? video.title,
                duration: videoDetails?.duration ?? 300,
                transcript: transcript,
                difficultyAnalysis: difficultyAnalysis
            )
            
            print("‚úÖ Completed: \(video.title.prefix(30))...")
            consecutiveFailures = 0  // Reset failure count on success
            return enhancedVideo
            
        } catch {
            print("‚ö†Ô∏è Failed to process video \(video.title.prefix(30)): \(error)")
            consecutiveFailures += 1
            
            return createFallbackVideo(video: video)
        }
    }
    
    // Create a fallback video with basic analysis when processing fails
    private func createFallbackVideo(video: YouTubeVideo) -> EnhancedYouTubeVideo {
        print("üîÑ Creating fallback video for: \(video.title.prefix(30))...")
        
        let basicAnalysis = analyzeVideoDifficultyComprehensive(
            title: video.title,
            description: "",
            transcript: nil,
            duration: 300,
            channelTitle: video.channel
        )
        
        return EnhancedYouTubeVideo(
            videoId: video.videoId,
            title: video.title,
            channel: video.channel,
            description: video.title,
            duration: 300,
            transcript: nil,
            difficultyAnalysis: basicAnalysis
        )
    }
    
    // MARK: - Caching Methods
    
    private func getCachedVideoDetails(videoId: String, apiKey: String) async throws -> EnhancedVideoDetails? {
        // Check cache first
        if let cachedDetails = videoDetailsCache[videoId] {
            print("üìÇ Using cached video details for: \(videoId)")
            return cachedDetails
        }
        
        // Fetch from API with retry and timeout
        let details = try await withRetry(maxAttempts: 2) {
            try await self.withTimeout(seconds: 10) {
                try await self.fetchVideoDetails(videoId: videoId, apiKey: apiKey)
            }
        }
        
        // Cache the result
        videoDetailsCache[videoId] = details
        print("üíæ Cached video details for: \(videoId)")
        
        return details
    }
    
    private func getCachedTranscript(videoId: String, apiKey: String) async -> VideoTranscript? {
        // Check cache first
        if let cachedTranscript = transcriptCache[videoId] {
            print("üìÇ Using cached transcript for: \(videoId)")
            return cachedTranscript
        }
        
        // Fetch from API with timeout (no retry to avoid quota waste)
        let transcript = await self.withTimeout(seconds: 5) {
            await self.fetchVideoTranscript(videoId: videoId, apiKey: apiKey)
        } ?? nil
        
        // Cache the result (even if nil to avoid repeated failed requests)
        transcriptCache[videoId] = transcript
        if transcript != nil {
            print("üíæ Cached transcript for: \(videoId)")
        }
        
        return transcript
    }
    
    private func clearExpiredCache() {
        // Simple cache clearing - clear all after expiration time
        // In a production app, you'd track individual timestamps
        DispatchQueue.main.asyncAfter(deadline: .now() + cacheExpirationTime) {
            self.videoDetailsCache.removeAll()
            self.transcriptCache.removeAll()
            print("üßπ Cleared expired cache")
        }
    }
    
    // Using EnhancedVideoDetails and EnhancedYouTubeVideo from YouTubeModels.swift
    
    private func fetchVideoDetails(videoId: String, apiKey: String) async throws -> EnhancedVideoDetails {
        let urlString = "https://www.googleapis.com/youtube/v3/videos?part=snippet,contentDetails,statistics&id=\(videoId)&key=\(apiKey)"
        
        guard let url = URL(string: urlString) else {
            throw SimpleAPIError.invalidSearchQuery
        }
        
        let (data, response) = try await URLSession.shared.data(from: url)
        
        guard let httpResponse = response as? HTTPURLResponse,
              200...299 ~= httpResponse.statusCode else {
            throw SimpleAPIError.networkError
        }
        
        guard let json = try JSONSerialization.jsonObject(with: data) as? [String: Any],
              let items = json["items"] as? [[String: Any]],
              let item = items.first,
              let snippet = item["snippet"] as? [String: Any],
              let contentDetails = item["contentDetails"] as? [String: Any],
              let statistics = item["statistics"] as? [String: Any] else {
            throw SimpleAPIError.parsingError
        }
        
        let description = snippet["description"] as? String ?? ""
        let durationISO = contentDetails["duration"] as? String ?? "PT0S"
        let viewCountString = statistics["viewCount"] as? String ?? "0"
        let publishedAt = snippet["publishedAt"] as? String ?? ""
        
        return EnhancedVideoDetails(
            description: description,
            duration: parseISO8601Duration(durationISO),
            viewCount: Int(viewCountString) ?? 0,
            publishedAt: publishedAt
        )
    }
    
    private func parseISO8601Duration(_ duration: String) -> Int {
        // Parse YouTube's PT#M#S format to seconds
        let pattern = "PT(?:(\\d+)M)?(?:(\\d+)S)?"
        guard let regex = try? NSRegularExpression(pattern: pattern) else {
            return 0
        }
        
        let range = NSRange(location: 0, length: duration.utf16.count)
        guard let match = regex.firstMatch(in: duration, range: range) else {
            return 0
        }
        
        var totalSeconds = 0
        
        // Extract minutes
        if match.range(at: 1).location != NSNotFound {
            let minutesRange = match.range(at: 1)
            let minutesString = (duration as NSString).substring(with: minutesRange)
            if let minutes = Int(minutesString) {
                totalSeconds += minutes * 60
            }
        }
        
        // Extract seconds
        if match.range(at: 2).location != NSNotFound {
            let secondsRange = match.range(at: 2)
            let secondsString = (duration as NSString).substring(with: secondsRange)
            if let seconds = Int(secondsString) {
                totalSeconds += seconds
            }
        }
        
        return totalSeconds
    }

    private func performYouTubeSearch(query: String, apiKey: String, maxResults: Int) async throws -> [YouTubeVideo] {
        let urlString = "https://www.googleapis.com/youtube/v3/search?part=snippet&maxResults=\(maxResults)&q=\(query.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed) ?? "")&type=video&key=\(apiKey)"
        
        guard let url = URL(string: urlString) else {
            print("‚ùå Invalid URL for YouTube search")
            return []
        }
        
        do {
            let (data, response) = try await URLSession.shared.data(from: url)
            
            guard let httpResponse = response as? HTTPURLResponse else {
                print("‚ùå Invalid HTTP response")
                return []
            }
            
            guard 200...299 ~= httpResponse.statusCode else {
                print("‚ùå YouTube API Error - Status Code: \(httpResponse.statusCode)")
                if let errorData = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
                   let error = errorData["error"] as? [String: Any],
                   let message = error["message"] as? String {
                    print("‚ùå YouTube API Error Message: \(message)")
                }
                return []
            }
            
            guard let json = try JSONSerialization.jsonObject(with: data) as? [String: Any],
                  let items = json["items"] as? [[String: Any]] else {
                print("‚ùå Failed to parse YouTube response")
                return []
            }
            
            return items.compactMap { item in
                guard let id = item["id"] as? [String: Any],
                      let videoId = id["videoId"] as? String,
                      let snippet = item["snippet"] as? [String: Any],
                      let title = snippet["title"] as? String,
                      let channelTitle = snippet["channelTitle"] as? String else {
                    return nil
                }
                
                return YouTubeVideo(
                    videoId: videoId,
                    title: title,
                    channel: channelTitle,
                    duration: "N/A"
                )
            }
        } catch {
            print("‚ùå Network error: \(error)")
            return []
        }
    }
    
    // MARK: - Smart Recommendation System
    
    struct DrillRecommendation {
        let exercise: Exercise
        let reason: String
        let priority: Int
        let category: RecommendationCategory
        let confidenceScore: Double
        let physicalIndicators: PhysicalIndicators
    }
    
    struct PhysicalIndicators {
        let intensity: PhysicalIntensity
        let duration: PhysicalDuration
        let physicalDemands: [PhysicalDemand]
        let heartRateZone: HeartRateZone
        let recoveryTime: RecoveryTime
    }
    
    enum PhysicalIntensity: Int, CaseIterable {
        case low = 1, moderate = 2, high = 3, veryHigh = 4, maximal = 5
        
        var displayName: String {
            switch self {
            case .low: return "Low"
            case .moderate: return "Moderate"
            case .high: return "High"
            case .veryHigh: return "Very High"
            case .maximal: return "Maximal"
            }
        }
        
        var color: String {
            switch self {
            case .low: return "green"
            case .moderate: return "yellow"
            case .high: return "orange"
            case .veryHigh: return "red"
            case .maximal: return "purple"
            }
        }
    }
    
    enum PhysicalDuration: CaseIterable {
        case short, medium, long, extended
        
        var displayName: String {
            switch self {
            case .short: return "5-15 min"
            case .medium: return "15-30 min"
            case .long: return "30-60 min"
            case .extended: return "60+ min"
            }
        }
        
        var estimatedMinutes: Int {
            switch self {
            case .short: return 10
            case .medium: return 22
            case .long: return 45
            case .extended: return 75
            }
        }
    }
    
    enum PhysicalDemand: String, CaseIterable {
        case cardio = "Cardio"
        case strength = "Strength"
        case agility = "Agility"
        case coordination = "Coordination"
        case balance = "Balance"
        case flexibility = "Flexibility"
        case power = "Power"
        case endurance = "Endurance"
        case speed = "Speed"
        case reaction = "Reaction Time"
        
        var icon: String {
            switch self {
            case .cardio: return "heart.fill"
            case .strength: return "dumbbell.fill"
            case .agility: return "figure.run"
            case .coordination: return "eye.fill"
            case .balance: return "figure.stand"
            case .flexibility: return "figure.yoga"
            case .power: return "bolt.fill"
            case .endurance: return "clock.fill"
            case .speed: return "speedometer"
            case .reaction: return "timer"
            }
        }
    }
    
    enum HeartRateZone: Int, CaseIterable {
        case recovery = 1, aerobic = 2, threshold = 3, anaerobic = 4, neuromuscular = 5
        
        var displayName: String {
            switch self {
            case .recovery: return "Zone 1 (Recovery)"
            case .aerobic: return "Zone 2 (Aerobic)"
            case .threshold: return "Zone 3 (Threshold)"
            case .anaerobic: return "Zone 4 (Anaerobic)"
            case .neuromuscular: return "Zone 5 (Neuromuscular)"
            }
        }
        
        var shortName: String {
            switch self {
            case .recovery: return "Z1"
            case .aerobic: return "Z2"
            case .threshold: return "Z3"
            case .anaerobic: return "Z4"
            case .neuromuscular: return "Z5"
            }
        }
        
        var percentageRange: String {
            switch self {
            case .recovery: return "50-60%"
            case .aerobic: return "60-70%"
            case .threshold: return "70-80%"
            case .anaerobic: return "80-90%"
            case .neuromuscular: return "90-100%"
            }
        }
    }
    
    enum RecoveryTime: CaseIterable {
        case minimal, short, moderate, long, extended
        
        var displayName: String {
            switch self {
            case .minimal: return "0-30 min"
            case .short: return "30 min - 2 hrs"
            case .moderate: return "2-6 hrs"
            case .long: return "6-24 hrs"
            case .extended: return "24+ hrs"
            }
        }
        
        var recommendation: String {
            switch self {
            case .minimal: return "Ready for next drill"
            case .short: return "Light activity recommended"
            case .moderate: return "Active recovery needed"
            case .long: return "Rest or light training"
            case .extended: return "Full recovery day needed"
            }
        }
    }
    
    enum RecommendationCategory {
        case skillGap
        case difficultyProgression
        case varietyBalance
        case repeatSuccess
        case complementarySkill
    }
    
    func getSmartRecommendations(for player: Player, limit: Int = 5) -> [DrillRecommendation] {
        print("üß† Generating smart recommendations for \(player.name ?? "Unknown")")
        
        // Ensure we're getting training history only for this specific player
        let trainingHistory = analyzeTrainingHistory(for: player)
        let skillGaps = identifySkillGaps(from: trainingHistory)
        let difficultyPattern = analyzeDifficultyProgression(from: trainingHistory)
        
        var recommendations: [DrillRecommendation] = []
        var globalUsedExercises: Set<String> = []
        
        // 1. Skill Gap Recommendations (Highest Priority)
        let skillGapRecs = generateSkillGapRecommendations(
            for: player,
            skillGaps: skillGaps,
            trainingHistory: trainingHistory,
            usedExercises: &globalUsedExercises
        )
        recommendations.append(contentsOf: skillGapRecs)
        
        // 2. Difficulty Progression Recommendations
        let progressionRecs = generateDifficultyProgressionRecommendations(
            for: player,
            currentLevel: difficultyPattern.averageDifficulty,
            performancePattern: difficultyPattern.performanceByDifficulty,
            trainingHistory: trainingHistory,
            usedExercises: &globalUsedExercises
        )
        recommendations.append(contentsOf: progressionRecs)
        
        // 3. Variety and Balance Recommendations
        let varietyRecs = generateVarietyRecommendations(
            for: player,
            trainingHistory: trainingHistory,
            usedExercises: &globalUsedExercises
        )
        recommendations.append(contentsOf: varietyRecs)
        
        // 4. Success Pattern Recommendations
        let successRecs = generateSuccessPatternRecommendations(
            for: player,
            trainingHistory: trainingHistory,
            usedExercises: &globalUsedExercises
        )
        recommendations.append(contentsOf: successRecs)
        
        // Sort by priority and confidence, then limit results
        let sortedRecommendations = recommendations
            .sorted { first, second in
                if first.priority != second.priority {
                    return first.priority < second.priority
                }
                return first.confidenceScore > second.confidenceScore
            }
            .prefix(limit)
        
        print("‚úÖ Generated \(sortedRecommendations.count) unique smart recommendations")
        print("üìù Used exercises: \(globalUsedExercises)")
        return Array(sortedRecommendations)
    }
    
    private func removeDuplicateRecommendations(_ recommendations: [DrillRecommendation]) -> [DrillRecommendation] {
        var uniqueRecommendations: [DrillRecommendation] = []
        var seenExerciseNames: Set<String> = []
        
        for recommendation in recommendations {
            let exerciseName = recommendation.exercise.name ?? ""
            
            if !seenExerciseNames.contains(exerciseName) {
                seenExerciseNames.insert(exerciseName)
                uniqueRecommendations.append(recommendation)
            } else {
                print("üîÑ Skipping duplicate recommendation: \(exerciseName)")
            }
        }
        
        print("üìä Filtered \(recommendations.count) recommendations to \(uniqueRecommendations.count) unique ones")
        return uniqueRecommendations
    }
    
    private struct TrainingHistory {
        let totalSessions: Int
        let recentSessions: [TrainingSession] // Last 10 sessions
        let skillFrequency: [String: Int]
        let categoryFrequency: [String: Int]
        let averagePerformance: Double
        let skillPerformance: [String: Double]
        let lastTrainingDate: Date?
    }
    
    private struct DifficultyPattern {
        let averageDifficulty: Double
        let performanceByDifficulty: [Int: Double]
        let readyForProgression: Bool
        let strugglingDifficulties: [Int]
    }
    
    private func analyzeTrainingHistory(for player: Player) -> TrainingHistory {
        guard let sessionsSet = player.sessions as? Set<TrainingSession> else {
            print("‚ö†Ô∏è No training sessions found for player \(player.name ?? "Unknown") (UID: \(player.firebaseUID ?? "Unknown"))")
            return TrainingHistory(
                totalSessions: 0,
                recentSessions: [],
                skillFrequency: [:],
                categoryFrequency: [:],
                averagePerformance: 0,
                skillPerformance: [:],
                lastTrainingDate: nil
            )
        }
        
        print("üìä Analyzing training history for player \(player.name ?? "Unknown") (UID: \(player.firebaseUID ?? "Unknown")) - found \(sessionsSet.count) sessions")
        
        let sessions = Array(sessionsSet).sorted { 
            ($0.date ?? Date.distantPast) > ($1.date ?? Date.distantPast) 
        }
        let recentSessions = Array(sessions.prefix(10))
        
        var skillFrequency: [String: Int] = [:]
        var categoryFrequency: [String: Int] = [:]
        var skillPerformanceData: [String: [Double]] = [:]
        var totalPerformance: [Double] = []
        
        for session in recentSessions {
            totalPerformance.append(Double(session.overallRating))
            
            if let exercisesSet = session.exercises as? Set<SessionExercise> {
                for sessionExercise in exercisesSet {
                    if let exercise = sessionExercise.exercise {
                        // Count category frequency
                        let category = exercise.category ?? "Unknown"
                        categoryFrequency[category, default: 0] += 1
                        
                        // Count skill frequency and track performance
                        if let skills = exercise.targetSkills {
                            for skill in skills {
                                skillFrequency[skill, default: 0] += 1
                                let performance = Double(sessionExercise.performanceRating)
                                skillPerformanceData[skill, default: []].append(performance)
                            }
                        }
                    }
                }
            }
        }
        
        // Calculate average skill performance
        let skillPerformance = skillPerformanceData.mapValues { performances in
            performances.reduce(0, +) / Double(performances.count)
        }
        
        let averagePerformance = totalPerformance.isEmpty ? 0 : 
            totalPerformance.reduce(0, +) / Double(totalPerformance.count)
        
        return TrainingHistory(
            totalSessions: sessions.count,
            recentSessions: recentSessions,
            skillFrequency: skillFrequency,
            categoryFrequency: categoryFrequency,
            averagePerformance: averagePerformance,
            skillPerformance: skillPerformance,
            lastTrainingDate: sessions.first?.date
        )
    }
    
    private func identifySkillGaps(from history: TrainingHistory) -> [String] {
        let allSkills = ["Ball Control", "Passing", "Shooting", "Dribbling", 
                        "Defending", "Speed", "Agility", "Endurance", "Vision", "Decision Making"]
        
        var gaps: [String] = []
        
        for skill in allSkills {
            let frequency = history.skillFrequency[skill] ?? 0
            let performance = history.skillPerformance[skill] ?? 0
            
            // Identify as gap if: rarely practiced OR poor performance
            if frequency < 2 || performance < 3.0 {
                gaps.append(skill)
            }
        }
        
        return gaps
    }
    
    private func analyzeDifficultyProgression(from history: TrainingHistory) -> DifficultyPattern {
        var difficultyPerformance: [Int: [Double]] = [:]
        var totalDifficulties: [Double] = []
        
        for session in history.recentSessions {
            if let exercisesSet = session.exercises as? Set<SessionExercise> {
                for sessionExercise in exercisesSet {
                    if let exercise = sessionExercise.exercise {
                        let difficulty = Int(exercise.difficulty)
                        let performance = Double(sessionExercise.performanceRating)
                        
                        difficultyPerformance[difficulty, default: []].append(performance)
                        totalDifficulties.append(Double(difficulty))
                    }
                }
            }
        }
        
        let averageDifficulty = totalDifficulties.isEmpty ? 2.0 :
            totalDifficulties.reduce(0, +) / Double(totalDifficulties.count)
        
        let performanceByDifficulty = difficultyPerformance.mapValues { performances in
            performances.reduce(0, +) / Double(performances.count)
        }
        
        // Determine if ready for progression (performing well at current level)
        let currentLevelPerformance = performanceByDifficulty[Int(averageDifficulty)] ?? 0
        let readyForProgression = currentLevelPerformance >= 4.0
        
        // Find struggling difficulties
        let strugglingDifficulties = performanceByDifficulty.compactMap { difficulty, performance in
            performance < 3.0 ? difficulty : nil
        }
        
        return DifficultyPattern(
            averageDifficulty: averageDifficulty,
            performanceByDifficulty: performanceByDifficulty,
            readyForProgression: readyForProgression,
            strugglingDifficulties: strugglingDifficulties
        )
    }
    
    private func generateSkillGapRecommendations(
        for player: Player,
        skillGaps: [String],
        trainingHistory: TrainingHistory,
        usedExercises: inout Set<String>
    ) -> [DrillRecommendation] {
        var recommendations: [DrillRecommendation] = []
        
        let exercises = fetchExercises(for: player)
        
        for gap in skillGaps.prefix(3) { // Focus on top 3 gaps
            // Find exercises for this skill that haven't been used yet
            let availableExercises = exercises.filter { exercise in
                let exerciseName = exercise.name ?? ""
                return exercise.targetSkills?.contains(gap) == true && 
                       !usedExercises.contains(exerciseName)
            }
            
            if let bestExercise = availableExercises.first {
                let exerciseName = bestExercise.name ?? ""
                usedExercises.insert(exerciseName)
                
                let reason = "You haven't practiced \(gap) recently. This drill will help improve this skill."
                let confidence = trainingHistory.skillFrequency[gap] == 0 ? 0.9 : 0.7
                
                let physicalIndicators = analyzePhysicalIndicators(for: bestExercise)
                recommendations.append(DrillRecommendation(
                    exercise: bestExercise,
                    reason: reason,
                    priority: 1,
                    category: .skillGap,
                    confidenceScore: confidence,
                    physicalIndicators: physicalIndicators
                ))
            }
        }
        
        return recommendations
    }
    
    private func generateDifficultyProgressionRecommendations(
        for player: Player,
        currentLevel: Double,
        performancePattern: [Int: Double],
        trainingHistory: TrainingHistory,
        usedExercises: inout Set<String>
    ) -> [DrillRecommendation] {
        var recommendations: [DrillRecommendation] = []
        let exercises = fetchExercises(for: player)
        
        // If performing well, suggest next difficulty level
        let currentPerformance = performancePattern[Int(currentLevel)] ?? 0
        if currentPerformance >= 4.0 && currentLevel < 5.0 {
            let nextLevel = min(5, Int(currentLevel) + 1)
            
            let availableExercises = exercises.filter { exercise in
                let exerciseName = exercise.name ?? ""
                return Int(exercise.difficulty) == nextLevel && !usedExercises.contains(exerciseName)
            }
            
            if let progressionExercise = availableExercises.first {
                let exerciseName = progressionExercise.name ?? ""
                usedExercises.insert(exerciseName)
                
                let physicalIndicators = analyzePhysicalIndicators(for: progressionExercise)
                recommendations.append(DrillRecommendation(
                    exercise: progressionExercise,
                    reason: "You're excelling at level \(Int(currentLevel)) drills. Time to challenge yourself!",
                    priority: 2,
                    category: .difficultyProgression,
                    confidenceScore: 0.8,
                    physicalIndicators: physicalIndicators
                ))
            }
        }
        
        // If struggling, suggest easier drills to build foundation
        if currentPerformance < 3.0 && currentLevel > 1.0 {
            let easierLevel = max(1, Int(currentLevel) - 1)
            
            let availableFoundationExercises = exercises.filter { exercise in
                let exerciseName = exercise.name ?? ""
                return Int(exercise.difficulty) == easierLevel && !usedExercises.contains(exerciseName)
            }
            
            if let foundationExercise = availableFoundationExercises.first {
                let exerciseName = foundationExercise.name ?? ""
                usedExercises.insert(exerciseName)
                
                let physicalIndicators = analyzePhysicalIndicators(for: foundationExercise)
                recommendations.append(DrillRecommendation(
                    exercise: foundationExercise,
                    reason: "Let's build your foundation with some level \(easierLevel) drills first.",
                    priority: 1,
                    category: .difficultyProgression,
                    confidenceScore: 0.85,
                    physicalIndicators: physicalIndicators
                ))
            }
        }
        
        return recommendations
    }
    
    private func generateVarietyRecommendations(
        for player: Player,
        trainingHistory: TrainingHistory,
        usedExercises: inout Set<String>
    ) -> [DrillRecommendation] {
        var recommendations: [DrillRecommendation] = []
        let exercises = fetchExercises(for: player)
        
        let allCategories = ["Technical", "Physical", "Tactical"]
        let underrepresentedCategories = allCategories.filter { category in
            (trainingHistory.categoryFrequency[category] ?? 0) < 2
        }
        
        for category in underrepresentedCategories.prefix(1) {
            let availableVarietyExercises = exercises.filter { exercise in
                let exerciseName = exercise.name ?? ""
                return exercise.category == category && !usedExercises.contains(exerciseName)
            }
            
            if let varietyExercise = availableVarietyExercises.first {
                let exerciseName = varietyExercise.name ?? ""
                usedExercises.insert(exerciseName)
                
                let physicalIndicators = analyzePhysicalIndicators(for: varietyExercise)
                recommendations.append(DrillRecommendation(
                    exercise: varietyExercise,
                    reason: "Add some variety with \(category.lowercased()) training.",
                    priority: 3,
                    category: .varietyBalance,
                    confidenceScore: 0.6,
                    physicalIndicators: physicalIndicators
                ))
            }
        }
        
        return recommendations
    }
    
    private func generateSuccessPatternRecommendations(
        for player: Player,
        trainingHistory: TrainingHistory,
        usedExercises: inout Set<String>
    ) -> [DrillRecommendation] {
        var recommendations: [DrillRecommendation] = []
        let exercises = fetchExercises(for: player)
        
        // Find skills where player performs well
        let strongSkills = trainingHistory.skillPerformance.filter { $0.value >= 4.0 }.keys
        
        for strongSkill in strongSkills.prefix(1) {
            let availableSuccessExercises = exercises.filter { exercise in
                let exerciseName = exercise.name ?? ""
                return exercise.targetSkills?.contains(strongSkill) == true &&
                       !usedExercises.contains(exerciseName) &&
                       !trainingHistory.recentSessions.contains { session in
                           session.exercises?.contains { sessionEx in
                               (sessionEx as? SessionExercise)?.exercise == exercise
                           } ?? false
                       }
            }
            
            if let similarExercise = availableSuccessExercises.first {
                let exerciseName = similarExercise.name ?? ""
                usedExercises.insert(exerciseName)
                
                let physicalIndicators = analyzePhysicalIndicators(for: similarExercise)
                recommendations.append(DrillRecommendation(
                    exercise: similarExercise,
                    reason: "You excel at \(strongSkill). Here's another drill to keep building on your strength.",
                    priority: 4,
                    category: .repeatSuccess,
                    confidenceScore: 0.7,
                    physicalIndicators: physicalIndicators
                ))
            }
        }
        
        return recommendations
    }
    
    private func fetchAllExercises() -> [Exercise] {
        let request: NSFetchRequest<Exercise> = Exercise.fetchRequest()
        
        do {
            return try context.fetch(request)
        } catch {
            print("‚ùå Failed to fetch exercises: \(error)")
            return []
        }
    }
    
    func removeDuplicateExercises(for player: Player) {
        print("üßπ Starting comprehensive duplicate cleanup for player \(player.name ?? "Unknown")...")
        let exercises = fetchExercises(for: player)
        var nameToExercises: [String: [Exercise]] = [:]
        var videoIdToExercises: [String: [Exercise]] = [:]
        
        // Group exercises by normalized name and video ID
        for exercise in exercises {
            let name = normalizeExerciseName(exercise.name ?? "")
            nameToExercises[name, default: []].append(exercise)
            
            // Also group by YouTube video ID if present
            if let description = exercise.exerciseDescription,
               let videoId = extractVideoId(from: description) {
                videoIdToExercises[videoId, default: []].append(exercise)
            }
        }
        
        var duplicatesRemoved = 0
        var processedExercises: Set<NSManagedObjectID> = []
        
        // Remove duplicates by name
        for (name, exerciseGroup) in nameToExercises {
            if exerciseGroup.count > 1 {
                print("üîç Found \(exerciseGroup.count) name duplicates for '\(name)'")
                
                // Keep the first one that hasn't been processed, delete the rest
                var kept = false
                for exercise in exerciseGroup {
                    if !kept && !processedExercises.contains(exercise.objectID) {
                        processedExercises.insert(exercise.objectID)
                        kept = true
                        print("‚úÖ Keeping: \(exercise.name ?? "Unnamed")")
                    } else {
                        print("üóëÔ∏è Deleting: \(exercise.name ?? "Unnamed")")
                        context.delete(exercise)
                        duplicatesRemoved += 1
                    }
                }
            } else if let exercise = exerciseGroup.first {
                processedExercises.insert(exercise.objectID)
            }
        }
        
        // Remove duplicates by YouTube video ID
        for (videoId, exerciseGroup) in videoIdToExercises {
            if exerciseGroup.count > 1 {
                print("üé• Found \(exerciseGroup.count) video ID duplicates for: \(videoId)")
                
                // Keep the first one that hasn't been deleted, delete the rest
                let remainingExercises = exerciseGroup.filter { !$0.isDeleted }
                if remainingExercises.count > 1 {
                    for duplicateExercise in remainingExercises.dropFirst() {
                        print("üóëÔ∏è Deleting YouTube duplicate: \(duplicateExercise.name ?? "Unnamed")")
                        context.delete(duplicateExercise)
                        duplicatesRemoved += 1
                    }
                }
            }
        }
        
        if duplicatesRemoved > 0 {
            save()
            print("üéâ Successfully removed \(duplicatesRemoved) duplicate exercises")
        } else {
            print("‚úÖ No duplicate exercises found")
        }
        
        // Print final count
        let finalCount = fetchAllExercises().count
        print("üìä Exercise library now contains \(finalCount) unique exercises")
    }
    
    private func normalizeExerciseName(_ name: String) -> String {
        // Normalize name for better duplicate detection
        return name
            .lowercased()
            .replacingOccurrences(of: "&amp;", with: "&")
            .replacingOccurrences(of: "...", with: "")
            .trimmingCharacters(in: .whitespacesAndNewlines)
    }
    
    private func extractVideoId(from description: String) -> String? {
        // Extract YouTube video ID from description
        if let range = description.range(of: "Video ID: ") {
            let startIndex = range.upperBound
            let remainingString = String(description[startIndex...])
            if let endIndex = remainingString.firstIndex(of: "\n") ?? remainingString.firstIndex(of: " ") {
                return String(remainingString[..<endIndex])
            } else {
                return remainingString
            }
        }
        return nil
    }
    
    private func analyzePhysicalIndicators(for exercise: Exercise) -> PhysicalIndicators {
        let exerciseName = exercise.name?.lowercased() ?? ""
        let category = exercise.category ?? ""
        let difficulty = Int(exercise.difficulty)
        let skills = exercise.targetSkills ?? []
        
        // Analyze intensity based on exercise characteristics
        let intensity = determineIntensity(
            name: exerciseName,
            category: category,
            difficulty: difficulty,
            skills: skills
        )
        
        // Determine duration based on exercise type and difficulty
        let duration = determineDuration(
            name: exerciseName,
            category: category,
            difficulty: difficulty
        )
        
        // Identify physical demands
        let physicalDemands = identifyPhysicalDemands(
            name: exerciseName,
            category: category,
            skills: skills
        )
        
        // Calculate heart rate zone based on intensity and demands
        let heartRateZone = determineHeartRateZone(
            intensity: intensity,
            physicalDemands: physicalDemands
        )
        
        // Estimate recovery time
        let recoveryTime = determineRecoveryTime(
            intensity: intensity,
            duration: duration,
            physicalDemands: physicalDemands
        )
        
        return PhysicalIndicators(
            intensity: intensity,
            duration: duration,
            physicalDemands: physicalDemands,
            heartRateZone: heartRateZone,
            recoveryTime: recoveryTime
        )
    }
    
    private func determineIntensity(name: String, category: String, difficulty: Int, skills: [String]) -> PhysicalIntensity {
        var intensityScore = difficulty // Base on difficulty (1-5)
        
        // High-intensity keywords
        let highIntensityKeywords = ["sprint", "explosive", "plyometric", "interval", "agility ladder", "shuttle run"]
        let lowIntensityKeywords = ["juggling", "stationary", "walking", "flexibility"]
        
        if highIntensityKeywords.contains(where: name.contains) {
            intensityScore += 1
        } else if lowIntensityKeywords.contains(where: name.contains) {
            intensityScore -= 1
        }
        
        // Category-based adjustments
        switch category {
        case "Physical":
            intensityScore += 1
        case "Technical":
            intensityScore += 0
        case "Tactical":
            intensityScore += 0
        default:
            break
        }
        
        // Skill-based adjustments
        if skills.contains("Speed") || skills.contains("Agility") {
            intensityScore += 1
        }
        if skills.contains("Endurance") {
            intensityScore += 0 // Endurance can be moderate to high
        }
        
        // Clamp to valid range
        let clampedScore = max(1, min(5, intensityScore))
        return PhysicalIntensity(rawValue: clampedScore) ?? .moderate
    }
    
    private func determineDuration(name: String, category: String, difficulty: Int) -> PhysicalDuration {
        // Duration keywords
        let shortKeywords = ["sprint", "explosive", "plyometric", "juggling"]
        let longKeywords = ["endurance", "run", "continuous", "session"]
        
        if shortKeywords.contains(where: name.contains) {
            return .short
        } else if longKeywords.contains(where: name.contains) {
            return difficulty >= 4 ? .long : .medium
        }
        
        // Category-based defaults
        switch category {
        case "Physical":
            return difficulty >= 3 ? .medium : .short
        case "Technical":
            return .medium
        case "Tactical":
            return .long
        default:
            return .medium
        }
    }
    
    private func identifyPhysicalDemands(name: String, category: String, skills: [String]) -> [PhysicalDemand] {
        var demands: Set<PhysicalDemand> = []
        
        // Name-based analysis
        let nameAnalysis: [String: PhysicalDemand] = [
            "sprint": .speed,
            "run": .cardio,
            "endurance": .endurance,
            "agility": .agility,
            "strength": .strength,
            "power": .power,
            "balance": .balance,
            "coordination": .coordination,
            "flexibility": .flexibility,
            "reaction": .reaction,
            "juggling": .coordination,
            "dribbling": .agility,
            "shooting": .power,
            "passing": .coordination
        ]
        
        for (keyword, demand) in nameAnalysis {
            if name.contains(keyword) {
                demands.insert(demand)
            }
        }
        
        // Skill-based analysis
        let skillMapping: [String: PhysicalDemand] = [
            "Speed": .speed,
            "Agility": .agility,
            "Endurance": .endurance,
            "Ball Control": .coordination,
            "Coordination": .coordination,
            "Shooting": .power,
            "Dribbling": .agility
        ]
        
        for skill in skills {
            if let demand = skillMapping[skill] {
                demands.insert(demand)
            }
        }
        
        // Category-based defaults
        switch category {
        case "Physical":
            demands.insert(.cardio)
            demands.insert(.strength)
        case "Technical":
            demands.insert(.coordination)
            demands.insert(.balance)
        case "Tactical":
            demands.insert(.reaction)
            demands.insert(.cardio)
        default:
            demands.insert(.coordination)
        }
        
        return Array(demands).sorted { $0.rawValue < $1.rawValue }
    }
    
    private func determineHeartRateZone(intensity: PhysicalIntensity, physicalDemands: [PhysicalDemand]) -> HeartRateZone {
        var zoneScore = intensity.rawValue
        
        // Adjust based on physical demands
        if physicalDemands.contains(.speed) || physicalDemands.contains(.power) {
            zoneScore += 1
        }
        if physicalDemands.contains(.endurance) {
            zoneScore += 0 // Endurance can be various zones
        }
        if physicalDemands.contains(.cardio) {
            zoneScore += 1
        }
        
        let clampedZone = max(1, min(5, zoneScore))
        return HeartRateZone(rawValue: clampedZone) ?? .aerobic
    }
    
    private func determineRecoveryTime(intensity: PhysicalIntensity, duration: PhysicalDuration, physicalDemands: [PhysicalDemand]) -> RecoveryTime {
        var recoveryScore = intensity.rawValue
        
        // Duration impact
        switch duration {
        case .short:
            recoveryScore += 0
        case .medium:
            recoveryScore += 1
        case .long:
            recoveryScore += 2
        case .extended:
            recoveryScore += 3
        }
        
        // High-impact demands increase recovery
        let highImpactDemands: [PhysicalDemand] = [.speed, .power, .strength]
        let highImpactCount = physicalDemands.filter { highImpactDemands.contains($0) }.count
        recoveryScore += highImpactCount
        
        // Convert to recovery time
        switch recoveryScore {
        case 1...3:
            return .minimal
        case 4...5:
            return .short
        case 6...7:
            return .moderate
        case 8...9:
            return .long
        default:
            return .extended
        }
    }
}
